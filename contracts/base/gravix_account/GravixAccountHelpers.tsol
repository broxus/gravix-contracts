pragma ever-solidity ^0.62.0;


import "./GravixAccountStorage.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Gas.tsol";
import "../../libraries/Callback.tsol";
import "../../libraries/PlatformTypes.tsol";
import "../../libraries/Errors.tsol";
import "../../libraries/Constants.tsol";
import {RPlatform as Platform} from "../../Platform.tsol";


abstract contract GravixAccountHelpers is GravixAccountStorage {
    function getDetails() external view responsible returns (
        uint32 _currentVersion, address _vault, address _user, address _referrer, address _grandReferrer, uint128 _referralBalance
    ) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (currentVersion, vault, user, referrer, grandReferrer, referralBalance);
    }

    function getReferrer() external view override responsible returns (address _user, address _referrer) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (user, referrer);
    }


    // @param price - 8 decimals number
    function applyOpenSpread(uint128 price, IGravixVault.PositionType _type, uint128 spread) public pure responsible returns (uint128 newPrice) {
        newPrice = _type == IGravixVault.PositionType.Long ?
            math.muldiv(price, (Constants.HUNDRED_PERCENT + spread), Constants.HUNDRED_PERCENT) :
            math.muldiv(price, (Constants.HUNDRED_PERCENT - spread), Constants.HUNDRED_PERCENT);
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } newPrice;
    }

    function applyCloseSpread(uint128 price, IGravixVault.PositionType _type, uint128 spread) public pure responsible returns (uint128 newPrice) {
        newPrice = _type == IGravixVault.PositionType.Long ?
            math.muldiv(price, (Constants.HUNDRED_PERCENT - spread), Constants.HUNDRED_PERCENT) :
            math.muldiv(price, (Constants.HUNDRED_PERCENT + spread), Constants.HUNDRED_PERCENT);
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } newPrice;
    }

    function getPosition(uint32 posKey) external view responsible returns (Position position) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } positions[posKey];
    }

    function getPositionsView(ViewInput[] inputs) external view responsible returns (PositionView[] positionsViews) {
        for (ViewInput input: inputs) {
            positionsViews.push(getPositionView(input));
        }

        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS }positionsViews;
    }

    function _getReferrer() internal view returns (address _referrer) {
        _referrer = referrerChecked ? referrer : address(0);
    }
    function _getGrandReferrer() internal view returns (address _grandReferrer) {
        _grandReferrer = grandReferrerChecked ? grandReferrer : address(0);
    }

    function isLatestVersion(uint32 _version) internal view returns(bool) {
        return _version == currentVersion;
    }

    function getPositionView(ViewInput input) public view responsible returns (PositionView positionView) {
        Position position = positions[input.positionKey];
        require (position.createdAt != 0, Errors.POSITION_NOT_FOUND);

        return {
            value: 0,
            bounce: false,
            flag: MsgFlag.REMAINING_GAS
        }_getPositionView(
            position,
            ViewInputInternal({
                funding: input.funding,
                assetPrice: input.assetPrice
            })
        );
    }

    function getPositionViewInternal(Position _position,uint128 _assetPrice) internal view returns (PositionView positionView) {
        bool isLong = _position.positionType == IGravixVault.PositionType.Long;

        ViewInputInternal input = ViewInputInternal({
            assetPrice: _assetPrice,
            funding: IGravixVault.Funding({
                accLongUSDFundingPerShare: isLong ? _position.accUSDFundingPerShare : 0,
                accShortUSDFundingPerShare: isLong ? 0 : _position.accUSDFundingPerShare
            })
        });

        return _getPositionView(_position, input);
    }

    function _getPositionView(Position _position, ViewInputInternal input) internal view returns (PositionView positionView) {

        bool isLong = _position.positionType == IGravixVault.PositionType.Long;

        uint128 collateral = _position.initialCollateral - _position.openFee;
        uint128 leveragedPositionUsd = math.muldiv(collateral, _position.leverage, Constants.LEVERAGE_BASE);
        uint128 leveragedPositionAsset = math.muldiv(leveragedPositionUsd, Constants.PRICE_DECIMALS, _position.openPrice);

        // borrow fee
        uint32 timePassed = now - _position.createdAt;
        uint128 borrowFeeShare = math.muldiv(_position.borrowBaseRatePerHour, timePassed, Constants.HOUR);
        uint128 borrowFeeUsd = math.muldiv(borrowFeeShare, leveragedPositionUsd, Constants.HUNDRED_PERCENT);

        // funding
        int256 newAccFunding = isLong ? input.funding.accLongUSDFundingPerShare : input.funding.accShortUSDFundingPerShare;
        int256 fundingDebt = math.muldiv(leveragedPositionAsset, _position.accUSDFundingPerShare, Constants.SCALING_FACTOR);
        // if fundingFee > 0, trader pays
        int256 fundingFeeUsd = math.muldiv(leveragedPositionAsset, newAccFunding, Constants.SCALING_FACTOR) - fundingDebt;
        // close price
//        uint128 stopLossTriggerPrice = _position.stopLoss.hasValue() ? _position.stopLoss.get().triggerPrice : 0;
//        uint128 takeProfitTriggerPrice = _position.takeProfit.hasValue() ? _position.takeProfit.get().triggerPrice : 0;

//        bool isClosedByStop = stopLossTriggerPrice == input.assetPrice || takeProfitTriggerPrice == input.assetPrice;

        uint128 closePrice = applyCloseSpread(input.assetPrice, _position.positionType, _position.baseSpreadRate);
        // pnl (no funding and borrow fees)
        // (closePrice/openPrice - 1)
        int256 pnl = int256(math.muldiv(closePrice, Constants.SCALING_FACTOR, _position.openPrice)) - Constants.SCALING_FACTOR;
        // * (-1) for shorts
        pnl = isLong ? pnl : -pnl;
        // * collateral * leverage
        pnl = math.muldiv(pnl, leveragedPositionUsd, Constants.SCALING_FACTOR);
        // liquidation price
        // collateral * 0.9
        int256 liqPriceDist = math.muldiv(collateral, (Constants.HUNDRED_PERCENT - _position.liquidationThresholdRate),  Constants.HUNDRED_PERCENT);
        // - borrowFee - fundingFeeUsd
        liqPriceDist -= borrowFeeUsd + fundingFeeUsd;
        // * openPrice / collateral / leverage
        liqPriceDist = math.muldiv(_position.openPrice, liqPriceDist, leveragedPositionUsd);

        int256 _liqPrice_raw = isLong
            ? math.muldiv(_position.openPrice - liqPriceDist, Constants.HUNDRED_PERCENT, Constants.HUNDRED_PERCENT - _position.baseSpreadRate)
            : math.muldiv(_position.openPrice + liqPriceDist, Constants.HUNDRED_PERCENT, Constants.HUNDRED_PERCENT + _position.baseSpreadRate);
        uint128 liqPrice = uint128(math.max(_liqPrice_raw, 0)); // price cant be negative

        int256 upPos = leveragedPositionUsd + pnl - fundingFeeUsd - borrowFeeUsd;
        uint128 closeFee = uint128(math.muldiv(math.max(upPos, 0), _position.closeFeeRate, Constants.HUNDRED_PERCENT));

        // now check if position could be liquidated
        //        int256 currentCollateral = collateral - borrowFee - fundingFee + pnl;
        //        uint128 liqThreshold = math.muldiv(collateral, position.liquidationThresholdRate, Constants.HUNDRED_PERCENT);
        //        bool liquidate = currentCollateral <= liqThreshold;
        bool liquidate = isLong ? input.assetPrice <= liqPrice : input.assetPrice >= liqPrice;

        return PositionView(
            _position,
            leveragedPositionUsd,
            closePrice,
            borrowFeeUsd,
            fundingFeeUsd,
            closeFee,
            liqPrice,
            pnl,
            liquidate,
            now
        );
    }


    function _getGravixAccountAddress(address _user) internal view returns (address) {
        return address(tvm.hash(_buildGravixAccountInitData(_buildGravixAccountParams(_user))));
    }

    function _buildGravixAccountParams(address _user) internal pure returns (TvmCell) {
        TvmBuilder builder;
        builder.store(_user);
        return builder.toCell();
    }

    function _buildGravixAccountInitData(TvmCell _initialData) internal view returns (TvmCell) {
        return tvm.buildStateInit({
            contr: Platform,
            varInit: {
                root: vault,
                platformType: PlatformTypes.GravixAccount,
                initialData: _initialData,
                platformCode: platformCode
            },
            pubkey: 0,
            code: platformCode
        });
    }

    function requestUpgrade(address _user,uint32 _currentVersion, Callback.CallMeta _meta) internal view {
        IGravixVault(vault).onGravixAccountRequestUpgrade{value: Gas.GRAVIX_ACC_UPGRADE_VALUE}(
            _user,
            _currentVersion,
            _meta
        );
    }

    function open_validateStopPositionParams(
        Position _position,
        uint128 _assetPrice,
        uint64 _maxPnlRate
    ) internal view returns (bool) {
        PositionView posView = getPositionViewInternal(_position, _assetPrice);
        bool isLong = _position.positionType == IGravixVault.PositionType.Long;


        bool isStopLooseExists = _position.stopLoss.hasValue();
        bool isTakeProfitExists = _position.takeProfit.hasValue();


        bool isStopLooseConfigValid;

        // impl stop loss logic
        if (isStopLooseExists) {
            IGravixVault.StopOrder stopLossConfig = _position.stopLoss.get();
            uint128 stopLossTriggerPrice = stopLossConfig.triggerPrice;
            bool isStopLoosePriceSatisfyLiquidationPrice = isLong
                ? stopLossTriggerPrice > posView.liquidationPrice
                : stopLossTriggerPrice < posView.liquidationPrice;

            bool isStopLoosePriceSatisfyAssetPrice = isLong
                ? stopLossTriggerPrice < _assetPrice
                : stopLossTriggerPrice > _assetPrice;

            uint128 collateral = _position.initialCollateral - _position.openFee;
            uint128 leveragedPositionUsd = math.muldiv(collateral, _position.leverage, Constants.LEVERAGE_BASE);
            uint128 maxStopLooseDist = math.muldiv(_position.openPrice, collateral, leveragedPositionUsd) * 75 / 100;

            bool isStopLossPriceSatisfyMaxStopLossPrice = isLong
                ? stopLossTriggerPrice >= (_position.openPrice - maxStopLooseDist)
                : stopLossTriggerPrice <= (_position.openPrice + maxStopLooseDist);

            isStopLooseConfigValid = isStopLoosePriceSatisfyLiquidationPrice && isStopLoosePriceSatisfyAssetPrice && isStopLossPriceSatisfyMaxStopLossPrice;
        } else {
            isStopLooseConfigValid = true;
        }

        //early return if stop loose config is not valid
        if (!isStopLooseConfigValid) {
            return false;
        }

        if (isTakeProfitExists) {
            IGravixVault.StopOrder takeProfitConfig = _position.takeProfit.get();
            uint128 takeProfitTriggerPrice = takeProfitConfig.triggerPrice;
            bool isTakeProfitPriceSatisfyOpenPrice = isLong
                ? takeProfitTriggerPrice > _position.openPrice
                : takeProfitTriggerPrice < _position.openPrice;


            bool isTakePriceSatisfyAssetPrice = isLong
                ? takeProfitTriggerPrice > _assetPrice
                : takeProfitTriggerPrice < _assetPrice;

            PositionView posView = getPositionViewInternal(_position, takeProfitTriggerPrice);
            int256 pnlLimit = math.muldiv(posView.position.initialCollateral, _maxPnlRate, Constants.HUNDRED_PERCENT);

            bool isTakeProfitPriceSatisfyMaxPnl = posView.pnl <= pnlLimit;

            return isTakeProfitPriceSatisfyOpenPrice && isTakePriceSatisfyAssetPrice && isTakeProfitPriceSatisfyMaxPnl;
        } else {
            return true;
        }
    }

    function isStopLoosePosition(
        Position _position
    ) internal pure returns (bool) {
       return _position.stopLoss.hasValue();
    }
    function isTakeProfitPosition(
        Position _position
    ) internal pure returns (bool) {
        return _position.takeProfit.hasValue();
    }

    function isStopLooseReady(
        Position _position,
        uint128 _assetPrice
    ) internal returns (bool) {
        optional(IGravixVault.StopOrder) stopLoss = _position.stopLoss;
        if (!stopLoss.hasValue()) {
            return false;
        }

        uint128 stopLossTriggerPrice = stopLoss.get().triggerPrice;

        return _position.positionType == IGravixVault.PositionType.Long
            ?  stopLossTriggerPrice >= _assetPrice
            : stopLossTriggerPrice < _assetPrice;
    }

    function isTakeProfitReady(
        Position _position,
        uint128 _assetPrice
    ) internal returns (bool) {
        optional(IGravixVault.StopOrder) takeProfit = _position.takeProfit;
        if (!takeProfit.hasValue()) {
            return false;
        }

        uint128 takeProfitTriggerPrice = takeProfit.get().triggerPrice;

        return _position.positionType == IGravixVault.PositionType.Long
            ? takeProfitTriggerPrice <= _assetPrice
            : takeProfitTriggerPrice > _assetPrice;
    }

    function convertStopPriceToStopOrder(uint128 _stopPrice) internal pure returns (optional(IGravixVault.StopOrder)) {
        if (_stopPrice == 0) {
            return null;
        }
        return IGravixVault.StopOrder({
            triggerPrice: _stopPrice,
            createdAt: now
        });
    }

    function _reserve() internal pure returns (uint128) {
        return math.max(address(this).balance - msg.value, CONTRACT_MIN_BALANCE);
    }


    modifier reserve() {
        tvm.rawReserve(_reserve(), 0);
        _;
    }

    modifier onlyGravixVault() {
        require (msg.sender == vault, Errors.NOT_VAULT);
        _;
    }
}

