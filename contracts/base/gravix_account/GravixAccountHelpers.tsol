pragma ever-solidity ^0.62.0;


import "./GravixAccountStorage.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Gas.tsol";
import "../../libraries/Callback.tsol";
import "../../libraries/PlatformTypes.tsol";
import "../../libraries/Errors.tsol";
import "locklift/src/console.tsol";
import "../../libraries/Constants.tsol";
import {RPlatform as Platform} from "../../Platform.tsol";


abstract contract GravixAccountHelpers is GravixAccountStorage {
    function getDetails() external view responsible returns (
        uint32 _currentVersion, address _vault, address _user, address _referrer, address _grandReferrer, uint128 _referralBalance
    ) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (currentVersion, vault, user, referrer, grandReferrer, referralBalance);
    }

    function getReferrer() external view override responsible returns (address _user, address _referrer) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } (user, referrer);
    }

    // @param price - 8 decimals number
    function applyOpenSpread(uint128 price, IGravixVault.PositionType _type, uint128 spread) public pure responsible returns (uint128 new_price) {
        new_price = _type == IGravixVault.PositionType.Long ?
            math.muldiv(price, (Constants.HUNDRED_PERCENT + spread), Constants.HUNDRED_PERCENT) :
            math.muldiv(price, (Constants.HUNDRED_PERCENT - spread), Constants.HUNDRED_PERCENT);
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } new_price;
    }

    function applyCloseSpread(uint128 price, IGravixVault.PositionType _type, uint128 spread) public pure responsible returns (uint128 new_price) {
        new_price = _type == IGravixVault.PositionType.Long ?
            math.muldiv(price, (Constants.HUNDRED_PERCENT - spread), Constants.HUNDRED_PERCENT) :
            math.muldiv(price, (Constants.HUNDRED_PERCENT + spread), Constants.HUNDRED_PERCENT);
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } new_price;
    }

    function getPosition(uint32 pos_key) external view responsible returns (Position position) {
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } positions[pos_key];
    }

    function getPositionsView(ViewInput[] inputs) external view responsible returns (PositionView[] positions_views) {
        for (ViewInput input: inputs) {
            positions_views.push(getPositionView(input));
        }

        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS }positions_views;
    }

    function getPositionView(ViewInput input) public view responsible returns (PositionView position_view) {
        Position position = positions[input.positionKey];
        require (position.createdAt != 0, Errors.POSITION_NOT_FOUND);

        bool is_long = position.positionType == IGravixVault.PositionType.Long;

        uint128 collateral = position.initialCollateral - position.openFee;
        uint128 leveraged_position_usd = math.muldiv(collateral, position.leverage, Constants.LEVERAGE_BASE);
        uint128 leveraged_position_asset = math.muldiv(leveraged_position_usd, Constants.PRICE_DECIMALS, position.openPrice);

        // borrow fee
        uint32 time_passed = now - position.createdAt;
        uint128 borrow_fee_share = math.muldiv(position.borrowBaseRatePerHour, time_passed, Constants.HOUR);
        uint128 borrow_fee_usd = math.muldiv(borrow_fee_share, leveraged_position_usd, Constants.HUNDRED_PERCENT);

        // funding
        int256 new_acc_funding = is_long ? input.funding.accLongUSDFundingPerShare : input.funding.accShortUSDFundingPerShare;
        int256 funding_debt = math.muldiv(leveraged_position_asset, position.accUSDFundingPerShare, Constants.SCALING_FACTOR);
        // if funding_fee > 0, trader pays
        int256 funding_fee_usd = math.muldiv(leveraged_position_asset, new_acc_funding, Constants.SCALING_FACTOR) - funding_debt;
        // close price
        uint128 close_price = applyCloseSpread(input.assetPrice, position.positionType, position.baseSpreadRate);
        // pnl (no funding and borrow fees)
        // (close_price/open_price - 1)
        int256 pnl = int256(math.muldiv(close_price, Constants.SCALING_FACTOR, position.openPrice)) - Constants.SCALING_FACTOR;
        // * (-1) for shorts
        pnl = is_long ? pnl : -pnl;
        // * collateral * leverage
        pnl = math.muldiv(pnl, leveraged_position_usd, Constants.SCALING_FACTOR);
        // liquidation price
        // collateral * 0.9
        int256 liq_price_dist = math.muldiv(collateral, (Constants.HUNDRED_PERCENT - position.liquidationThresholdRate),  Constants.HUNDRED_PERCENT);
        // - borrow_fee - funding_fee_usd
        liq_price_dist -= borrow_fee_usd + funding_fee_usd;
        // * open_price / collateral / leverage
        liq_price_dist = math.muldiv(position.openPrice, liq_price_dist, leveraged_position_usd);

        int256 _liq_price_raw = is_long ?
            math.muldiv(position.openPrice - liq_price_dist, Constants.HUNDRED_PERCENT, Constants.HUNDRED_PERCENT - position.baseSpreadRate) :
            math.muldiv(position.openPrice + liq_price_dist, Constants.HUNDRED_PERCENT, Constants.HUNDRED_PERCENT + position.baseSpreadRate);
        uint128 liq_price = uint128(math.max(_liq_price_raw, 0)); // price cant be negative

        int256 up_pos = leveraged_position_usd + pnl - funding_fee_usd - borrow_fee_usd;
        uint128 close_fee = uint128(math.muldiv(math.max(up_pos, 0), position.closeFeeRate, Constants.HUNDRED_PERCENT));

        // now check if position could be liquidated
        //        int256 current_collateral = collateral - borrow_fee - funding_fee + pnl;
        //        uint128 liq_threshold = math.muldiv(collateral, position.liquidationThresholdRate, Constants.HUNDRED_PERCENT);
        //        bool liquidate = current_collateral <= liq_threshold;
        bool liquidate = is_long ? input.assetPrice <= liq_price : input.assetPrice >= liq_price;

        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS }PositionView(
            position,
            leveraged_position_usd,
            close_price,
            borrow_fee_usd,
            funding_fee_usd,
            close_fee,
            liq_price,
            pnl,
            liquidate,
            now
        );
    }

    function _getGravixAccountAddress(address user) internal view returns (address) {
        return address(tvm.hash(_buildGravixAccountInitData(_buildGravixAccountParams(user))));
    }

    function _buildGravixAccountParams(address user) internal pure returns (TvmCell) {
        TvmBuilder builder;
        builder.store(user);
        return builder.toCell();
    }

    function _buildGravixAccountInitData(TvmCell _initialData) internal view returns (TvmCell) {
        return tvm.buildStateInit({
            contr: Platform,
            varInit: {
                root: vault,
                platformType: PlatformTypes.GravixAccount,
                initialData: _initialData,
                platformCode: platform_code
            },
            pubkey: 0,
            code: platform_code
        });
    }


    function _reserve() internal pure returns (uint128) {
        return math.max(address(this).balance - msg.value, CONTRACT_MIN_BALANCE);
    }


    modifier reserve() {
        tvm.rawReserve(_reserve(), 0);
        _;
    }

    modifier onlyGravixVault() {
        require (msg.sender == vault, Errors.NOT_VAULT);
        _;
    }
}

