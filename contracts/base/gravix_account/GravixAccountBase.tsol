pragma ever-solidity ^0.62.0;


import "broxus-token-contracts/contracts/interfaces/ITokenRootUpgradeable.tsol";
import "broxus-token-contracts/contracts/interfaces/ITokenWalletUpgradeable.tsol";
import "broxus-token-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Gas.tsol";
import "../../libraries/Callback.tsol";
import "../../interfaces/IGravixVault.tsol";
import "./GravixAccountHelpers.tsol";
import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";
import "locklift/src/console.tsol";


abstract contract GravixAccountBase is GravixAccountHelpers {
    function process_withdrawReferralBalance(Callback.CallMeta meta) external override onlyGravixVault reserve {
        IGravixVault(vault).finish_withdrawReferralBalance{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, referralBalance, meta
        );
        referralBalance = 0;
    }

    function process_sendReferrerFee(
        uint128 amount, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        referralBalance += amount;
        meta.send_gas_to.transfer(0, false, MsgFlag.ALL_NOT_RESERVED);
    }

    function process_requestMarketOrder(
        uint32, IGravixVault.PendingMarketOrder pending_request
    ) external override onlyGravixVault reserve {
        request_counter += 1;
        marketOrders[request_counter] = MarketOrder(
            pending_request.marketIdx,
            pending_request.positionType,
            pending_request.collateral,
            pending_request.expectedPrice,
            pending_request.leverage,
            pending_request.maxSlippageRate,
            pending_request.openFeeRate,
            pending_request.closeFeeRate,
            pending_request.baseSpreadRate,
            pending_request.liquidationThresholdRate,
            pending_request.borrowBaseRatePerHour
        );

        // always trying to get grandReferrer on 1st request if referrer is set
        if (request_counter == 1 && referrer != address(0)) {
            address referrer_acc = _getGravixAccountAddress(referrer);
            first_request = pending_request;
            IGravixAccount(referrer_acc).getReferrer{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getReferrer
            }();
            return;
        }

        IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            pending_request, request_counter
        );
    }

    function process_getReferrer(address _referrer, address _grand_referrer) external override reserve {
        require (msg.sender == _getGravixAccountAddress(_referrer), Errors.NOT_GRAVIX_ACCOUNT);

        // we got this callback from our referrer account
        // + we got correct grand referrer address
        if (_referrer == referrer && _grand_referrer != address(0)) {
            grandReferrer = _grand_referrer;
            // we dont really need data from our grand referrer, we just want to check if he exists
            address grand_referrer_acc = _getGravixAccountAddress(grandReferrer);
            IGravixAccount(grand_referrer_acc).getReferrer{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getReferrer
            }();
            return;
        }

        // if we get here, it means we have no grand referrer/we got correct callback from grand referrer
        IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            first_request, 1 // we can get here only of 1st request
        );
    }

    function process_executeMarketOrder(
        uint32 position_key,
        uint32 market_idx,
        uint128 position_size_asset,
        IGravixVault.PositionType position_type,
        uint128 asset_price,
        uint64 dynamic_spread,
        int256 accUSDFundingPerShare,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        MarketOrder request = marketOrders[position_key];

        // check if request exists + double check market idx
        if (request.collateral == 0 || request.marketIdx != market_idx) {
            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, position_key, market_idx, 0, position_size_asset, asset_price, position_type, meta
            );
            return;
        }

        delete marketOrders[position_key];

        uint128 allowed_delta = math.muldiv(request.expectedPrice, request.maxSlippageRate, Constants.HUNDRED_PERCENT);
        uint128 min_price = request.expectedPrice - allowed_delta;
        uint128 max_price = request.expectedPrice + allowed_delta;

        // add base + dynamic spread
        uint128 open_price = applyOpenSpread(asset_price, request.positionType, request.baseSpreadRate + dynamic_spread);

        if (open_price < min_price || open_price > max_price) {
            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, position_key, market_idx, request.collateral, position_size_asset, asset_price, position_type, meta
            );
            return;
        }

        uint128 leveraged_position_usd = math.muldiv(request.collateral, request.leverage, Constants.LEVERAGE_BASE);
        uint128 open_fee = math.muldiv(leveraged_position_usd, request.openFeeRate, Constants.HUNDRED_PERCENT);

        Position opened_position = Position(
            request.marketIdx,
            request.positionType,
            request.collateral,
            open_fee,
            open_price,
            asset_price,
            request.leverage,
            accUSDFundingPerShare,
            request.borrowBaseRatePerHour,
            request.baseSpreadRate,
            request.closeFeeRate,
            request.liquidationThresholdRate,
            now
        );
        positions[position_key] = opened_position;

        IGravixVault(vault).finish_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, position_key, opened_position, referrer, grandReferrer, meta
        );
    }

    function process_cancelMarketOrder(
        uint32 position_key, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        MarketOrder _request = marketOrders[position_key];

        // check request exists
        if (_request.collateral == 0) {
            IGravixVault(vault).revert_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, position_key, meta
            );
            return;
        }

        delete marketOrders[position_key];

        IGravixVault(vault).finish_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, position_key, _request.collateral, meta
        );
    }

    function process_liquidatePositions(
        address liquidator,
        uint32 position_key,
        uint32 market_idx,
        uint128 asset_price,
        IGravixVault.Funding funding,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[position_key];

        // if collateral == 0, position does not exist
        if (_position.initialCollateral == 0 || _position.marketIdx != market_idx) {
            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, liquidator, position_key, market_idx, meta
            );
            return;
        }

        PositionView position_view = getPositionView(ViewInput(position_key, asset_price, funding));
        if (position_view.liquidate) {
            delete positions[position_key];
            IGravixVault(vault).finish_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, liquidator, position_key, asset_price, position_view, referrer, grandReferrer, meta
            );
        } else {
            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, liquidator, position_key, market_idx, meta
            );
        }
    }

    function process_closePosition(
        uint32 position_key,
        uint32 market_idx,
        uint128 asset_price,
        IGravixVault.Funding funding,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[position_key];

        if (_position.initialCollateral == 0 || _position.marketIdx != market_idx) {
            IGravixVault(vault).revert_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, position_key, market_idx, meta
            );
            return;
        }

        PositionView position_view = getPositionView(ViewInput(position_key, asset_price, funding));
        delete positions[position_key];

        IGravixVault(vault).finish_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, position_key, asset_price, position_view, referrer, grandReferrer, meta
        );
    }

    function process_addCollateral(
        uint128 amount, uint32 market_idx, uint32 position_key, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[position_key];

        // if collateral == 0, position does not exist
        if (_position.initialCollateral == 0 || _position.marketIdx != market_idx) {
            IGravixVault(vault).revert_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, amount, market_idx, position_key, meta
            );
            return;
        }

        uint128 old_collateral = _position.initialCollateral - _position.openFee;
        uint128 new_collateral = old_collateral + amount;
        uint128 leveraged_position_usd = math.muldiv(old_collateral, _position.leverage, Constants.LEVERAGE_BASE);
        uint32 new_leverage = uint32(math.muldiv(leveraged_position_usd, Constants.LEVERAGE_BASE, new_collateral));

        _position.initialCollateral += amount;
        uint32 old_leverage = _position.leverage;
        _position.leverage = new_leverage;

        positions[position_key] = _position;

        IGravixVault(vault).finish_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            amount,
            _position,
            old_leverage,
            position_key,
            meta
        );
    }

    function process_removeCollateral(
        uint128 amount,
        uint32 position_key,
        uint32 market_idx,
        uint32 max_leverage,
        uint128 min_collateral,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[position_key];
        uint128 old_collateral = _position.initialCollateral - _position.openFee;

        // math.min because at this point we dont know if position exists
        uint128 new_collateral = old_collateral - math.min(amount, old_collateral);
        uint128 leveraged_position_usd = math.muldiv(old_collateral, _position.leverage, Constants.LEVERAGE_BASE);
        // math.max(col, 1) because we dont want to div by 0 if position does not exist
        uint32 new_leverage = uint32(math.muldiv(leveraged_position_usd, Constants.LEVERAGE_BASE, math.max(new_collateral, 1)));

        // if collateral == 0, position does not exist
        if (
            _position.initialCollateral == 0 ||
            (old_collateral - math.min(old_collateral, amount) < min_collateral) ||
            _position.marketIdx != market_idx ||
            new_leverage > max_leverage
        ) {
            IGravixVault(vault).revert_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, amount, position_key, market_idx, meta
            );
            return;
        }

        _position.initialCollateral -= amount;
        uint32 old_leverage = _position.leverage;
        _position.leverage = new_leverage;

        positions[position_key] = _position;

        IGravixVault(vault).finish_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            amount,
            _position,
            old_leverage,
            position_key,
            meta
        );
    }

    onBounce(TvmSlice slice) external {
        tvm.accept();

        uint32 functionId = slice.decode(uint32);
        // we can get here because of failed referrer/grand referrer callback
        if (functionId == tvm.functionId(IGravixAccount.getReferrer)) {
            tvm.rawReserve(_reserve(), 0);
            if (referrer != address(0) && grandReferrer != address(0)) {
                // If both addresses are set, it means we:
                // 1. Checked that referrer exists and got grand referrer address
                // 2. Tried to check that grand referrer exists and got bounce
                delete grandReferrer;
            } else if (referrer != address(0)) {
                // We tried to check that referrer exists and got bounce
                delete referrer;
            }
            IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(first_request, 1);
            delete first_request;
        }
    }
}
