pragma ever-solidity ^0.62.0;


import "../../interfaces/IGravixVault.tsol";
import "../../interfaces/IGravixVault.tsol";
import "../../libraries/Callback.tsol";
import "./GravixAccountHelpers.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";


abstract contract GravixAccountBase is GravixAccountHelpers {
    function process_withdrawReferralBalance(Callback.CallMeta meta) external override onlyGravixVault reserve {
        IGravixVault(vault).finish_withdrawReferralBalance{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, referralBalance, meta
        );
        referralBalance = 0;
    }

    function process_sendReferrerFee(
        uint128 amount, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        referralBalance += amount;
        meta.sendGasTo.transfer(0, false, MsgFlag.ALL_NOT_RESERVED);

    }

    function process_requestMarketOrder(
        uint32 _reqNonce,
        IGravixVault.PendingMarketOrder _pendingRequest,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {

        if (!isLatestVersion(_accountVersion)) {
            requestUpgrade(user, currentVersion, _pendingRequest.meta);

            IGravixVault(vault).revert_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _reqNonce,
                _pendingRequest
            );
            return;
        }

        requestCounter += 1;
        marketOrders[requestCounter] = MarketOrder(
            _pendingRequest.marketIdx,
            _pendingRequest.positionType,
            _pendingRequest.collateral,
            _pendingRequest.expectedPrice,
            _pendingRequest.leverage,
            _pendingRequest.maxSlippageRate,
            _pendingRequest.openFeeRate,
            _pendingRequest.closeFeeRate,
            _pendingRequest.baseSpreadRate,
            _pendingRequest.liquidationThresholdRate,
            _pendingRequest.borrowBaseRatePerHour,
            _pendingRequest.stopLossTriggerPrice,
            _pendingRequest.takeProfitTriggerPrice
        );
        // always trying to get grandReferrer on 1st request if referrer is set
        if (requestCounter == 1 && referrer != address(0)) {
            retrieveReferrers();
        }

        IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _reqNonce, _pendingRequest, requestCounter
        );
    }

    function retrieveReferrers() internal view {
        address referrerAcc = _getGravixAccountAddress(referrer);
        IGravixAccount(referrerAcc).getReferrer{
            value: Gas.GET_REFERRER_VALUE,
            callback: IGravixAccount.process_getReferrer
        }();
    }
    function process_getReferrer(address _referrer, address _grandReferrer) external override reserve {
        require (msg.sender == _getGravixAccountAddress(_referrer), Errors.NOT_GRAVIX_ACCOUNT);

        if (!referrerChecked) {
            // we got this callback from our referrer account
            referrerChecked = true;
        } else {
            grandReferrerChecked = true;
        }

        // we got this callback from our referrer account
        // + we got correct grand referrer address
        if (_referrer == _getReferrer() && _grandReferrer != address(0)) {
            grandReferrer = _grandReferrer;
            // we dont really need data from our grand referrer, we just want to check if he exists
            address grandReferrerAcc = _getGravixAccountAddress(grandReferrer);
            IGravixAccount(grandReferrerAcc).getReferrer{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getReferrer
            }();

            return;
        }

        user.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED, bounce: false});
    }


    function process_executeMarketOrder(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _positionSizeAsset,
        IGravixVault.PositionType _positionType,
        uint128 _assetPrice,
        uint64 _dynamicSpread,
        int256 _accUSDFundingPerShare,
        uint64 _maxPnlRate,
        uint64 _minStopLossRate,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        MarketOrder request = marketOrders[_positionKey];
        bool isLatestVersion = isLatestVersion(_accountVersion);

        // check if request exists + double check market idx
        if (
            request.collateral == 0 ||
            request.marketIdx != _marketIdx ||
            !isLatestVersion
        ) {
            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }

            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                0,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            return;
        }

        uint128 allowedDelta = math.muldiv(request.expectedPrice, request.maxSlippageRate, Constants.HUNDRED_PERCENT);
        uint128 minPrice = request.expectedPrice - allowedDelta;
        uint128 maxPrice = request.expectedPrice + allowedDelta;

        // add base + dynamic spread
        uint128 openPrice = applyOpenSpread(
            _assetPrice,
            request.positionType,
            request.baseSpreadRate + _dynamicSpread
        );

        uint128 leveragedPositionUsd = math.muldiv(request.collateral, request.leverage, Constants.LEVERAGE_BASE);
        uint128 openFee = math.muldiv(leveragedPositionUsd, request.openFeeRate, Constants.HUNDRED_PERCENT);



        bool triggersValid = validateTriggerPrices(
            request.collateral - openFee,
            request.leverage,
            request.positionType,
            request.baseSpreadRate,
            _maxPnlRate,
            _minStopLossRate,
            openPrice,
            request.takeProfitTriggerPrice,
            request.stopLossTriggerPrice
        );

        // TODO: add reason to revert
        // checking slippage
        if (openPrice < minPrice || openPrice > maxPrice || !triggersValid) {
            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                request.collateral,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            delete marketOrders[_positionKey];
            return;
        }

        optional(PositionTrigger) stopLoss;
        if (request.stopLossTriggerPrice > 0) {
            stopLoss = PositionTrigger(request.stopLossTriggerPrice, now);
        }

        optional(PositionTrigger) takeProfit;
        if  (request.takeProfitTriggerPrice > 0) {
            takeProfit = PositionTrigger(request.takeProfitTriggerPrice, now);
        }
        Position openedPosition = Position(
            request.marketIdx,
            request.positionType,
            request.collateral,
            openFee,
            openPrice,
            _assetPrice,
            request.leverage,
            _accUSDFundingPerShare,
            request.borrowBaseRatePerHour,
            request.baseSpreadRate,
            request.closeFeeRate,
            request.liquidationThresholdRate,
            now,
            stopLoss,
            takeProfit
        );

        positions[_positionKey] = openedPosition;

        IGravixVault(vault).finish_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _positionKey,
            openedPosition,
            _getReferrer(),
            _getGrandReferrer(),
            _meta
        );
    }

    function process_cancelMarketOrder(
        uint32 _positionKey,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        MarketOrder _request = marketOrders[_positionKey];

        bool isLatestVersion = isLatestVersion(_accountVersion);

        // check request exists
        if (_request.collateral == 0 || !isLatestVersion) {
            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);

            }
            IGravixVault(vault).revert_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _meta
            );
            return;
        }

        delete marketOrders[_positionKey];

        IGravixVault(vault).finish_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, _positionKey, _request.collateral, _meta
        );
    }

    function process_requestLimitOrder(
        uint32 _reqNonce,
        IGravixVault.PendingLimitOrder _pendingRequest,
        uint64 _maxPnlRate,
        uint64 _minStopLossRate,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {

        bool isPriceOk;
        if (_pendingRequest.orderType == IGravixVault.LimitOrderType.Limit) {
            isPriceOk = _pendingRequest.positionType == IGravixVault.PositionType.Long
                ? _pendingRequest.triggerPrice < _pendingRequest.assetPrice
                : _pendingRequest.triggerPrice > _pendingRequest.assetPrice;
        }

        if (_pendingRequest.orderType == IGravixVault.LimitOrderType.Stop) {
            isPriceOk = _pendingRequest.positionType == IGravixVault.PositionType.Long
                ? _pendingRequest.triggerPrice > _pendingRequest.assetPrice
                : _pendingRequest.triggerPrice < _pendingRequest.assetPrice;
        }

        bool isLatestVersion = isLatestVersion(_accountVersion);


        uint128 openPrice = applyOpenSpread(
            _pendingRequest.triggerPrice,
            _pendingRequest.positionType,
            _pendingRequest.baseSpreadRate
        );

        uint128 leveragedPositionUsd = math.muldiv(
            _pendingRequest.collateral,
            _pendingRequest.leverage,
            Constants.LEVERAGE_BASE
        );

        uint128 openFee = math.muldiv(
            leveragedPositionUsd,
            _pendingRequest.openFeeRate,
            Constants.HUNDRED_PERCENT
        );

        bool triggersValid = validateTriggerPrices(
            _pendingRequest.collateral - openFee,
            _pendingRequest.leverage,
            _pendingRequest.positionType,
            _pendingRequest.baseSpreadRate,
            _maxPnlRate,
            _minStopLossRate,
            openPrice,
            _pendingRequest.takeProfitTriggerPrice,
            _pendingRequest.stopLossTriggerPrice
        );

        if (!isPriceOk || !isLatestVersion || !triggersValid) {
            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _pendingRequest.meta);
            }

            IGravixVault(vault).revert_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _reqNonce,
                _pendingRequest
            );
            return;
        }
        // always trying to get grandReferrer on 1st request if referrer is set

        if (requestCounter == 1 && referrer != address(0)) {
            retrieveReferrers();
        }

        requestCounter += 1;
        limitOrders[requestCounter] = LimitOrder(
            _pendingRequest.marketIdx,
            _pendingRequest.positionType,
            _pendingRequest.orderType,
            _pendingRequest.collateral,
            _pendingRequest.triggerPrice,
            _pendingRequest.leverage,
            _pendingRequest.openFeeRate,
            _pendingRequest.closeFeeRate,
            _pendingRequest.baseSpreadRate,
            _pendingRequest.liquidationThresholdRate,
            _pendingRequest.borrowBaseRatePerHour,
            _pendingRequest.stopLossTriggerPrice,
            _pendingRequest.takeProfitTriggerPrice
        );

        IGravixVault(vault).finish_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _reqNonce,
            _pendingRequest,
            requestCounter
        );
    }

    function process_executeLimitOrder(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _collateral,
        uint32 _leverage,
        uint128 _positionSizeAsset,
        IGravixVault.PositionType _positionType,
        uint128 _assetPrice,
        int256 _accUSDFundingPerShare,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        LimitOrder request = limitOrders[_positionKey];

        bool isLatestVersion = isLatestVersion(_accountVersion);
        // check if request exists + double check market idx
        if (
            request.collateral == 0 ||
            request.marketIdx != _marketIdx ||
            request.positionType != _positionType ||
            request.collateral != _collateral ||
            request.leverage != _leverage ||
            !isLatestVersion
        ) {

            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }

            IGravixVault(vault).revert_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                0,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            return;
        }


        bool isPriceOk;
        if (request.limitOrderType == IGravixVault.LimitOrderType.Limit) {
            isPriceOk = request.positionType == IGravixVault.PositionType.Long
                ? request.triggerPrice >= _assetPrice
                : request.triggerPrice <= _assetPrice;
        }

        if (request.limitOrderType == IGravixVault.LimitOrderType.Stop) {
            isPriceOk = request.positionType == IGravixVault.PositionType.Long
                ? request.triggerPrice <= _assetPrice
                : request.triggerPrice >= _assetPrice;
        }

        if (!isPriceOk) {
            IGravixVault(vault).revert_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                request.collateral,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            return;
        }

        delete limitOrders[_positionKey];

        // add base spread
        uint128 openPrice = applyOpenSpread(
            request.triggerPrice,
            request.positionType,
            request.baseSpreadRate
        );

        uint128 leveragedPositionUsd = math.muldiv(request.collateral, request.leverage, Constants.LEVERAGE_BASE);
        uint128 openFee = math.muldiv(leveragedPositionUsd, request.openFeeRate, Constants.HUNDRED_PERCENT);



        Position openedPosition = Position(
            request.marketIdx,
            request.positionType,
            request.collateral,
            openFee,
            openPrice,
            _assetPrice,
            request.leverage,
            _accUSDFundingPerShare,
            request.borrowBaseRatePerHour,
            request.baseSpreadRate,
            request.closeFeeRate,
            request.liquidationThresholdRate,
            now,
            convertStopPriceToStopOrder(request.stopLossTriggerPrice),
            convertStopPriceToStopOrder(request.takeProfitTriggerPrice)
        );
        positions[_positionKey] = openedPosition;

        IGravixVault(vault).finish_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _positionKey,
            openedPosition,
            referrer,
            grandReferrer,
            _meta
        );
    }

    function process_cancelLimitOrder(
        uint32 _positionKey,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        LimitOrder _request = limitOrders[_positionKey];

        bool isLatestVersion = isLatestVersion(_accountVersion);

        // check request exists
        if (_request.collateral == 0 || !isLatestVersion) {

            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }

            IGravixVault(vault).revert_cancelLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _meta
            );
            return;
        }

        delete limitOrders[_positionKey];

        IGravixVault(vault).finish_cancelLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _positionKey,
            _request.collateral,
            _request.stopLossTriggerPrice> 0 || _request.takeProfitTriggerPrice> 0,
            _meta
        );
    }

    function process_setOrUpdatePositionTriggers(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _assetPrice,
        IGravixVault.Funding funding,
        uint128 _stopLossTriggerPrice,
        uint128 _takeProfitTriggerPrice,
        uint64 _maxPnlRate,
        uint64 _minStopLossRate,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        bool isLatestVersion = isLatestVersion(_accountVersion);
        Position position = positions[_positionKey];
        bool isFirstPositionTriggerPrice = !position.stopLoss.hasValue() || !position.takeProfit.hasValue();

        // TODO: check position exists ?
        if (!isLatestVersion || position.marketIdx != _marketIdx) {
            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }
            IGravixVault(vault).revert_setOrUpdatePositionTriggers{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                _meta
            );
            return;
        }

        if (_stopLossTriggerPrice > 0) {
            position.stopLoss = PositionTrigger(_stopLossTriggerPrice, now);
        }

        if  (_takeProfitTriggerPrice > 0) {
            position.takeProfit = PositionTrigger(_takeProfitTriggerPrice, now);
        }

        bool isLong = position.positionType == IGravixVault.PositionType.Long;
        int256 newAccFunding = isLong ? funding.accLongUSDFundingPerShare : funding.accShortUSDFundingPerShare;
        uint128 collateral = position.initialCollateral - position.openFee;

        (uint128 leveragedPosUsd, uint128 leveragedPosAsset) = GravixMath.calculateLeveragedPosition(
            collateral,
            position.leverage,
            position.openPrice
        );
        uint128 borrowFee = GravixMath.calculateBorrowFee(leveragedPosUsd, position.createdAt, position.borrowBaseRatePerHour);
        int256 fundingFee = GravixMath.calculateFundingFee(
            newAccFunding,
            position.accUSDFundingPerShare,
            leveragedPosAsset
        );

        bool triggersValid = validateTriggerPrices(
            collateral,
            position.leverage,
            borrowFee,
            fundingFee,
            position.positionType,
            position.baseSpreadRate,
            _maxPnlRate,
            _minStopLossRate,
            _assetPrice,
            _takeProfitTriggerPrice,
            _stopLossTriggerPrice
        );

        if (!triggersValid) {
            IGravixVault(vault).revert_setOrUpdatePositionTriggers{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                _meta
            );
            return;
        }

        positions[_positionKey] = position;
        IGravixVault(vault).finish_setOrUpdatePositionTriggers{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            position,
            _positionKey,
            _marketIdx,
            isFirstPositionTriggerPrice,
            _meta
        );
    }

    function process_removePositionTriggers(
        uint32 _positionKey,
        uint32 _marketIdx,
        bool _removeStopLoss,
        bool _removeTakeProfit,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        bool isLatestVersion = isLatestVersion(_accountVersion);
        Position position = positions[_positionKey];
        if (!isLatestVersion || position.marketIdx != _marketIdx) {

            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }

            IGravixVault(vault).revert_removePositionTriggers{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                _meta
            );
            return;
        }
        uint32 prevCountOfStops;
        uint32 updatedCountOfStops;
        bool stopLossRemoved;
        bool takeProfitRemoved;

        if (position.stopLoss.hasValue()) {
            prevCountOfStops += 1;
            if (_removeStopLoss) {
                stopLossRemoved = true;
                updatedCountOfStops += 1;
                position.stopLoss = null;
            }
        }
        if (position.takeProfit.hasValue()) {
            prevCountOfStops += 1;
            if (_removeTakeProfit) {
                takeProfitRemoved = true;
                updatedCountOfStops += 1;
                position.takeProfit = null;
            }
        }

        positions[_positionKey] = position;

        IGravixVault(vault).finish_removePositionTriggers{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _positionKey,
            _marketIdx,
            prevCountOfStops,
            updatedCountOfStops,
            stopLossRemoved,
            takeProfitRemoved,
            _meta
        );
    }

    function process_executePositionsTriggers(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _assetPrice,
        IGravixVault.TriggerPositionType _stopOrderType,
        IGravixVault.Funding _funding,
        address _initiator,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        bool isLatestVersion = isLatestVersion(_accountVersion);
        Position position = positions[_positionKey];

        if (!isLatestVersion || position.marketIdx != _marketIdx) {

            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }
            IGravixVault(vault).revert_executePositionsTriggers{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                _meta
            );
            return;
        }

        _executePositionTriggers(
            _positionKey,
            _marketIdx,
            _assetPrice,
            _stopOrderType,
            _funding,
            _initiator,
            _meta
        );

    }

    function _executePositionTriggers(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _assetPrice,
        IGravixVault.TriggerPositionType _stopOrderType,
        IGravixVault.Funding _funding,
        address _initiator,
        Callback.CallMeta _meta
    ) internal {
        Position position = positions[_positionKey];
        bool isReadyToClose;
        uint128 stopPrice;
        if (_stopOrderType == IGravixVault.TriggerPositionType.StopLoss && position.stopLoss.hasValue()) {
            isReadyToClose = isStopLossReady(position, _assetPrice);
            stopPrice = position.stopLoss.get().triggerPrice;
        }

        if (_stopOrderType == IGravixVault.TriggerPositionType.TakeProfit && position.takeProfit.hasValue()) {
            isReadyToClose = isTakeProfitReady(position, _assetPrice);
            stopPrice = position.takeProfit.get().triggerPrice;
        }

        if (!isReadyToClose) {
            IGravixVault(vault).revert_executePositionsTriggers{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                _meta
            );
            return;
        }


        PositionView positionView = getPositionView(
            ViewInput(_positionKey, stopPrice, _funding)
        );
        delete positions[_positionKey];

        IGravixVault(vault).finish_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _positionKey,
            stopPrice,
            positionView,
            referrer,
            grandReferrer,
            _initiator,
            _meta
        );
    }


    function process_liquidatePositions(
        address _liquidator,
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _assetPrice,
        IGravixVault.Funding _funding,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        Position _position = positions[_positionKey];

        bool isLatestVersion = isLatestVersion(_accountVersion);

        // if collateral == 0, position does not exist
        if (
            _position.initialCollateral == 0 ||
            _position.marketIdx != _marketIdx ||
            !isLatestVersion
        ) {

            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }

            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _liquidator, _positionKey, _marketIdx, _meta
            );
            return;
        }

        if (_position.stopLoss.hasValue()) {
            _executePositionTriggers(
                _positionKey,
                _marketIdx,
                _assetPrice,
                IGravixVault.TriggerPositionType.StopLoss,
                _funding,
                _liquidator,
                _meta
            );
            return;
        }

        PositionView positionView = getPositionView(ViewInput(_positionKey, _assetPrice, _funding));
        if (positionView.liquidate) {
            delete positions[_positionKey];
            IGravixVault(vault).finish_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _liquidator,
                _positionKey,
                _assetPrice,
                positionView,
                referrer,
                grandReferrer,
                _meta
            );
        } else {
            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _liquidator, _positionKey, _marketIdx, _meta
            );
        }
    }

    function process_closePosition(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _assetPrice,
        IGravixVault.Funding _funding,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        Position _position = positions[_positionKey];

        bool isLatestVersion = isLatestVersion(_accountVersion);

        if (
            _position.initialCollateral == 0 ||
            _position.marketIdx != _marketIdx ||
            !isLatestVersion
        ) {

            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }

            IGravixVault(vault).revert_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _marketIdx, _meta
            );
            return;
        }

        PositionView positionView = getPositionView(ViewInput(_positionKey, _assetPrice, _funding));
        delete positions[_positionKey];

        IGravixVault(vault).finish_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _positionKey,
            _assetPrice,
            positionView,
            referrer,
            grandReferrer,
            user,
            _meta
        );
    }

    function process_addCollateral(
        uint128 amount,
        uint32 marketIdx,
        uint32 positionKey,
        Callback.CallMeta meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        Position _position = positions[positionKey];

        bool isLatestVersion = isLatestVersion(_accountVersion);

        // if collateral == 0, position does not exist
        if (
            _position.initialCollateral == 0 ||
            _position.marketIdx != marketIdx ||
            !isLatestVersion
        ) {
            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, meta);
            }
            IGravixVault(vault).revert_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, amount, marketIdx, positionKey, meta
            );
            return;
        }

        uint128 oldCollateral = _position.initialCollateral - _position.openFee;
        uint128 newCollateral = oldCollateral + amount;
        uint128 leveragedPositionUsd = math.muldiv(oldCollateral, _position.leverage, Constants.LEVERAGE_BASE);
        uint32 newLeverage = uint32(math.muldiv(leveragedPositionUsd, Constants.LEVERAGE_BASE, newCollateral));

        _position.initialCollateral += amount;
        uint32 oldLeverage = _position.leverage;
        _position.leverage = newLeverage;

        positions[positionKey] = _position;

        IGravixVault(vault).finish_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            amount,
            _position,
            oldLeverage,
            positionKey,
            meta
        );
    }

    function process_removeCollateral(
        uint128 _amount,
        uint32 _positionKey,
        uint32 _marketIdx,
        uint32 _maxLeverage,
        uint128 _minCollateral,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {

        Position _position = positions[_positionKey];
        uint128 oldCollateral = _position.initialCollateral - _position.openFee;

        // math.min because at this point we dont know if position exists
        uint128 newCollateral = oldCollateral - math.min(_amount, oldCollateral);
        uint128 leveragedPositionUsd = math.muldiv(oldCollateral, _position.leverage, Constants.LEVERAGE_BASE);
        // math.max(col, 1) because we dont want to div by 0 if position does not exist
        uint32 newLeverage = uint32(math.muldiv(leveragedPositionUsd, Constants.LEVERAGE_BASE, math.max(newCollateral, 1)));

        bool isLatestVersion = isLatestVersion(_accountVersion);

        // if collateral == 0, position does not exist
        if (
            _position.initialCollateral == 0 ||
            (oldCollateral - math.min(oldCollateral, _amount) < _minCollateral) ||
            _position.marketIdx != _marketIdx ||
            newLeverage > _maxLeverage ||
            !isLatestVersion
        ) {

            if (!isLatestVersion) {
                requestUpgrade(user, currentVersion, _meta);
            }

            IGravixVault(vault).revert_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _amount, _positionKey, _marketIdx, _meta
            );
            return;
        }

        _position.initialCollateral -= _amount;
        uint32 oldLeverage = _position.leverage;
        _position.leverage = newLeverage;

        positions[_positionKey] = _position;

        IGravixVault(vault).finish_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _amount,
            _position,
            oldLeverage,
            _positionKey,
            _meta
        );
    }

    onBounce(TvmSlice slice) external {
        tvm.accept();

        uint32 functionId = slice.decode(uint32);
        // we can get here because of failed referrer/grand referrer callback

        if (functionId == tvm.functionId(IGravixAccount.getReferrer)) {
            tvm.rawReserve(_reserve(), 0);
            if (referrer != address(0) && grandReferrer != address(0)) {
                // If both addresses are set, it means we:
                // 1. Checked that referrer exists and got grand referrer address
                // 2. Tried to check that grand referrer exists and got bounce
                delete grandReferrer;
            } else if (referrer != address(0)) {
                // We tried to check that referrer exists and got bounce
                delete referrer;
            }

            user.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED});
        }
    }
}
