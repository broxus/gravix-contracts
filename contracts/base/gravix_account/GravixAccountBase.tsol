pragma ever-solidity ^0.62.0;



import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Callback.tsol";
import "../../interfaces/IGravixVault.tsol";
import "./GravixAccountHelpers.tsol";
import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";



abstract contract GravixAccountBase is GravixAccountHelpers {
    function process_withdrawReferralBalance(Callback.CallMeta meta) external override onlyGravixVault reserve {
        IGravixVault(vault).finish_withdrawReferralBalance{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, referralBalance, meta
        );
        referralBalance = 0;
    }

    function process_sendReferrerFee(
        uint128 amount, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        referralBalance += amount;
        meta.sendGasTo.transfer(0, false, MsgFlag.ALL_NOT_RESERVED);
    }

    function process_requestMarketOrder(
        uint32 reqNonce, IGravixVault.PendingMarketOrder pendingRequest
    ) external override onlyGravixVault reserve {
        requestCounter += 1;
        marketOrders[requestCounter] = MarketOrder(
            pendingRequest.marketIdx,
            pendingRequest.positionType,
            pendingRequest.collateral,
            pendingRequest.expectedPrice,
            pendingRequest.leverage,
            pendingRequest.maxSlippageRate,
            pendingRequest.openFeeRate,
            pendingRequest.closeFeeRate,
            pendingRequest.baseSpreadRate,
            pendingRequest.liquidationThresholdRate,
            pendingRequest.borrowBaseRatePerHour
        );

        // always trying to get grandReferrer on 1st request if referrer is set
        if (requestCounter == 1 && referrer != address(0)) {
            address referrerAcc = _getGravixAccountAddress(referrer);
            firstRequest = pendingRequest;
            firstReqNonce = reqNonce;
            IGravixAccount(referrerAcc).getReferrer{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getReferrer
            }();
            return;
        }

        IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            reqNonce, pendingRequest, requestCounter
        );
    }

    function process_getReferrer(address _referrer, address _grandReferrer) external override reserve {
        require (msg.sender == _getGravixAccountAddress(_referrer), Errors.NOT_GRAVIX_ACCOUNT);

        // we got this callback from our referrer account
        // + we got correct grand referrer address
        if (_referrer == referrer && _grandReferrer != address(0)) {
            grandReferrer = _grandReferrer;
            // we dont really need data from our grand referrer, we just want to check if he exists
            address grandReferrerAcc = _getGravixAccountAddress(grandReferrer);
            IGravixAccount(grandReferrerAcc).getReferrer{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getReferrer
            }();
            return;
        }

        // if we get here, it means we have no grand referrer/we got correct callback from grand referrer
        IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            firstReqNonce, firstRequest, 1 // we can get here only of 1st request
        );
    }

    function process_executeMarketOrder(
        uint32 positionKey,
        uint32 marketIdx,
        uint128 positionSizeAsset,
        IGravixVault.PositionType positionType,
        uint128 assetPrice,
        uint64 dynamicSpread,
        int256 accUSDFundingPerShare,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        MarketOrder request = marketOrders[positionKey];

        // check if request exists + double check market idx
        if (request.collateral == 0 || request.marketIdx != marketIdx) {
            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, positionKey, marketIdx, 0, positionSizeAsset, assetPrice, positionType, meta
            );
            return;
        }

        delete marketOrders[positionKey];

        uint128 allowedDelta = math.muldiv(request.expectedPrice, request.maxSlippageRate, Constants.HUNDRED_PERCENT);
        uint128 minPrice = request.expectedPrice - allowedDelta;
        uint128 maxPrice = request.expectedPrice + allowedDelta;

        // add base + dynamic spread
        uint128 openPrice = applyOpenSpread(
            assetPrice,
            request.positionType,
            request.baseSpreadRate + dynamicSpread
        );

        if (openPrice < minPrice || openPrice > maxPrice) {
            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, positionKey, marketIdx, request.collateral,
                positionSizeAsset, assetPrice, positionType, meta
            );
            return;
        }

        uint128 leveragedPositionUsd = math.muldiv(request.collateral, request.leverage, Constants.LEVERAGE_BASE);
        uint128 openFee = math.muldiv(leveragedPositionUsd, request.openFeeRate, Constants.HUNDRED_PERCENT);

        Position openedPosition = Position(
            request.marketIdx,
            request.positionType,
            request.collateral,
            openFee,
            openPrice,
            assetPrice,
            request.leverage,
            accUSDFundingPerShare,
            request.borrowBaseRatePerHour,
            request.baseSpreadRate,
            request.closeFeeRate,
            request.liquidationThresholdRate,
            now
        );
        positions[positionKey] = openedPosition;

        IGravixVault(vault).finish_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, positionKey, openedPosition, referrer, grandReferrer, meta
        );
    }

    function process_cancelMarketOrder(
        uint32 positionKey, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        MarketOrder _request = marketOrders[positionKey];

        // check request exists
        if (_request.collateral == 0) {
            IGravixVault(vault).revert_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, positionKey, meta
            );
            return;
        }

        delete marketOrders[positionKey];

        IGravixVault(vault).finish_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, positionKey, _request.collateral, meta
        );
    }

    function process_liquidatePositions(
        address liquidator,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 assetPrice,
        IGravixVault.Funding funding,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[positionKey];

        // if collateral == 0, position does not exist
        if (_position.initialCollateral == 0 || _position.marketIdx != marketIdx) {
            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, liquidator, positionKey, marketIdx, meta
            );
            return;
        }

        PositionView positionView = getPositionView(ViewInput(positionKey, assetPrice, funding));
        if (positionView.liquidate) {
            delete positions[positionKey];
            IGravixVault(vault).finish_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, liquidator, positionKey, assetPrice, positionView,
                referrer, grandReferrer, meta
            );
        } else {
            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, liquidator, positionKey, marketIdx, meta
            );
        }
    }

    function process_closePosition(
        uint32 positionKey,
        uint32 marketIdx,
        uint128 assetPrice,
        IGravixVault.Funding funding,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[positionKey];

        if (_position.initialCollateral == 0 || _position.marketIdx != marketIdx) {
            IGravixVault(vault).revert_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, positionKey, marketIdx, meta
            );
            return;
        }

        PositionView positionView = getPositionView(ViewInput(positionKey, assetPrice, funding));
        delete positions[positionKey];

        IGravixVault(vault).finish_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, positionKey, assetPrice, positionView,
            referrer, grandReferrer, meta
        );
    }

    function process_addCollateral(
        uint128 amount, uint32 marketIdx, uint32 positionKey, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[positionKey];

        // if collateral == 0, position does not exist
        if (_position.initialCollateral == 0 || _position.marketIdx != marketIdx) {
            IGravixVault(vault).revert_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, amount, marketIdx, positionKey, meta
            );
            return;
        }

        uint128 oldCollateral = _position.initialCollateral - _position.openFee;
        uint128 newCollateral = oldCollateral + amount;
        uint128 leveragedPositionUsd = math.muldiv(oldCollateral, _position.leverage, Constants.LEVERAGE_BASE);
        uint32 newLeverage = uint32(math.muldiv(leveragedPositionUsd, Constants.LEVERAGE_BASE, newCollateral));

        _position.initialCollateral += amount;
        uint32 oldLeverage = _position.leverage;
        _position.leverage = newLeverage;

        positions[positionKey] = _position;

        IGravixVault(vault).finish_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            amount,
            _position,
            oldLeverage,
            positionKey,
            meta
        );
    }

    function process_removeCollateral(
        uint128 amount,
        uint32 positionKey,
        uint32 marketIdx,
        uint32 maxLeverage,
        uint128 minCollateral,
        Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        Position _position = positions[positionKey];
        uint128 oldCollateral = _position.initialCollateral - _position.openFee;

        // math.min because at this point we dont know if position exists
        uint128 newCollateral = oldCollateral - math.min(amount, oldCollateral);
        uint128 leveragedPositionUsd = math.muldiv(oldCollateral, _position.leverage, Constants.LEVERAGE_BASE);
        // math.max(col, 1) because we dont want to div by 0 if position does not exist
        uint32 newLeverage = uint32(math.muldiv(leveragedPositionUsd, Constants.LEVERAGE_BASE, math.max(newCollateral, 1)));

        // if collateral == 0, position does not exist
        if (
            _position.initialCollateral == 0 ||
            (oldCollateral - math.min(oldCollateral, amount) < minCollateral) ||
            _position.marketIdx != marketIdx ||
            newLeverage > maxLeverage
        ) {
            IGravixVault(vault).revert_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, amount, positionKey, marketIdx, meta
            );
            return;
        }

        _position.initialCollateral -= amount;
        uint32 oldLeverage = _position.leverage;
        _position.leverage = newLeverage;

        positions[positionKey] = _position;

        IGravixVault(vault).finish_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            amount,
            _position,
            oldLeverage,
            positionKey,
            meta
        );
    }

    onBounce(TvmSlice slice) external {
        tvm.accept();

        uint32 functionId = slice.decode(uint32);
        // we can get here because of failed referrer/grand referrer callback
        if (functionId == tvm.functionId(IGravixAccount.getReferrer)) {
            tvm.rawReserve(_reserve(), 0);
            if (referrer != address(0) && grandReferrer != address(0)) {
                // If both addresses are set, it means we:
                // 1. Checked that referrer exists and got grand referrer address
                // 2. Tried to check that grand referrer exists and got bounce
                delete grandReferrer;
            } else if (referrer != address(0)) {
                // We tried to check that referrer exists and got bounce
                delete referrer;
            }
            IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(firstReqNonce, firstRequest, 1);
            delete firstRequest;
            delete firstReqNonce;
        }
    }
}
