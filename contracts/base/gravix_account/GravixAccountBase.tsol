pragma ever-solidity ^0.62.0;



import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Callback.tsol";
import "../../interfaces/IGravixVault.tsol";
import "./GravixAccountHelpers.tsol";
import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";
import "locklift/src/console.tsol";



abstract contract GravixAccountBase is GravixAccountHelpers {
    function process_withdrawReferralBalance(Callback.CallMeta meta) external override onlyGravixVault reserve {
        IGravixVault(vault).finish_withdrawReferralBalance{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, referralBalance, meta
        );
        referralBalance = 0;
    }

    function process_sendReferrerFee(
        uint128 amount, Callback.CallMeta meta
    ) external override onlyGravixVault reserve {
        referralBalance += amount;
        meta.sendGasTo.transfer(0, false, MsgFlag.ALL_NOT_RESERVED);
    }

    function process_requestMarketOrder(
        uint32 _reqNonce,
        IGravixVault.PendingMarketOrder _pendingRequest,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _pendingRequest.meta);

            IGravixVault(vault).revert_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _reqNonce,
                _pendingRequest
            );
            return;
        }
        requestCounter += 1;
        marketOrders[requestCounter] = MarketOrder(
            _pendingRequest.marketIdx,
            _pendingRequest.positionType,
            _pendingRequest.collateral,
            _pendingRequest.expectedPrice,
            _pendingRequest.leverage,
            _pendingRequest.maxSlippageRate,
            _pendingRequest.openFeeRate,
            _pendingRequest.closeFeeRate,
            _pendingRequest.baseSpreadRate,
            _pendingRequest.liquidationThresholdRate,
            _pendingRequest.borrowBaseRatePerHour
        );

        // always trying to get grandReferrer on 1st request if referrer is set
        if (requestCounter == 1 && referrer != address(0)) {
            address referrerAcc = _getGravixAccountAddress(referrer);
            firstMarketRequest = _pendingRequest;
            firstReqNonce = _reqNonce;
            IGravixAccount(referrerAcc).getReferrerForMarketOrder{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getMarketReferrer
            }();
            return;
        }

        IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _reqNonce, _pendingRequest, requestCounter
        );
    }


    function process_getMarketReferrer(address _referrer, address _grandReferrer) external override reserve {
        require (msg.sender == _getGravixAccountAddress(_referrer), Errors.NOT_GRAVIX_ACCOUNT);

        // we got this callback from our referrer account
        // + we got correct grand referrer address
        if (_referrer == referrer && _grandReferrer != address(0)) {
            grandReferrer = _grandReferrer;
            // we dont really need data from our grand referrer, we just want to check if he exists
            address grandReferrerAcc = _getGravixAccountAddress(grandReferrer);
            IGravixAccount(grandReferrerAcc).getReferrerForMarketOrder{
                value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getMarketReferrer
            }();
            return;
        }

        // if we get here, it means we have no grand referrer/we got correct callback from grand referrer
        IGravixVault(vault).finish_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            firstReqNonce, firstMarketRequest, 1 // we can get here only of 1st request
        );
    }

    function process_getLimitReferrer(address _referrer, address _grandReferrer) external override reserve {
        require (msg.sender == _getGravixAccountAddress(_referrer), Errors.NOT_GRAVIX_ACCOUNT);

        // we got this callback from our referrer account
        // + we got correct grand referrer address
        if (_referrer == referrer && _grandReferrer != address(0)) {
            grandReferrer = _grandReferrer;
            // we dont really need data from our grand referrer, we just want to check if he exists
            address grandReferrerAcc = _getGravixAccountAddress(grandReferrer);
            IGravixAccount(grandReferrerAcc).getReferrerForLimitOrder{
                    value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getLimitReferrer
                }();
            return;
        }

        // if we get here, it means we have no grand referrer/we got correct callback from grand referrer
        IGravixVault(vault).finish_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            firstReqNonce, firstLimitRequest, 1 // we can get here only of 1st request
        );
    }

    function process_executeMarketOrder(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _positionSizeAsset,
        IGravixVault.PositionType _positionType,
        uint128 _assetPrice,
        uint64 _dynamicSpread,
        int256 _accUSDFundingPerShare,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        MarketOrder request = marketOrders[_positionKey];

        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _meta);

            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                request.collateral,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            return;
        }
        // check if request exists + double check market idx
        if (request.collateral == 0 || request.marketIdx != _marketIdx) {
            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _marketIdx, 0, _positionSizeAsset, _assetPrice, _positionType, _meta
            );
            return;
        }

        delete marketOrders[_positionKey];

        uint128 allowedDelta = math.muldiv(request.expectedPrice, request.maxSlippageRate, Constants.HUNDRED_PERCENT);
        uint128 minPrice = request.expectedPrice - allowedDelta;
        uint128 maxPrice = request.expectedPrice + allowedDelta;

        // add base + dynamic spread
        uint128 openPrice = applyOpenSpread(
            _assetPrice,
            request.positionType,
            request.baseSpreadRate + _dynamicSpread
        );

        if (openPrice < minPrice || openPrice > maxPrice) {
            IGravixVault(vault).revert_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _marketIdx, request.collateral,
                _positionSizeAsset, _assetPrice, _positionType, _meta
            );
            return;
        }

        uint128 leveragedPositionUsd = math.muldiv(request.collateral, request.leverage, Constants.LEVERAGE_BASE);
        uint128 openFee = math.muldiv(leveragedPositionUsd, request.openFeeRate, Constants.HUNDRED_PERCENT);

        Position openedPosition = Position(
            request.marketIdx,
            request.positionType,
            request.collateral,
            openFee,
            openPrice,
            _assetPrice,
            request.leverage,
            _accUSDFundingPerShare,
            request.borrowBaseRatePerHour,
            request.baseSpreadRate,
            request.closeFeeRate,
            request.liquidationThresholdRate,
            now
        );
        positions[_positionKey] = openedPosition;

        IGravixVault(vault).finish_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, _positionKey, openedPosition, referrer, grandReferrer, _meta
        );
    }

    function process_cancelMarketOrder(
        uint32 _positionKey,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        MarketOrder _request = marketOrders[_positionKey];

        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _meta);
            IGravixVault(vault).revert_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _meta
            );
            return;
        }
        // check request exists
        if (_request.collateral == 0) {
            IGravixVault(vault).revert_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _meta
            );
            return;
        }

        delete marketOrders[_positionKey];

        IGravixVault(vault).finish_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, _positionKey, _request.collateral, _meta
        );
    }

    function process_requestLimitOrder(
        uint32 _reqNonce,
        IGravixVault.PendingLimitOrder _pendingRequest,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {

        if (_accountVersion != currentVersion) {

            requestUpgrade(user, currentVersion, _pendingRequest.meta);

            IGravixVault(vault).revert_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _reqNonce,
                _pendingRequest
            );
            return;
        }
        requestCounter += 1;
        limitOrders[requestCounter] = LimitOrder(
            _pendingRequest.marketIdx,
            _pendingRequest.positionType,
            _pendingRequest.orderType,
            _pendingRequest.collateral,
            _pendingRequest.triggerPrice,
            _pendingRequest.leverage,
            _pendingRequest.openFeeRate,
            _pendingRequest.closeFeeRate,
            _pendingRequest.baseSpreadRate,
            _pendingRequest.liquidationThresholdRate,
            _pendingRequest.borrowBaseRatePerHour
        );

        bool isPriceOk;
        if (_pendingRequest.orderType == IGravixVault.LimitOrderType.Limit) {
            isPriceOk = _pendingRequest.positionType == IGravixVault.PositionType.Long
                ? _pendingRequest.triggerPrice < _pendingRequest.assetPrice
                : _pendingRequest.triggerPrice > _pendingRequest.assetPrice;
        }

        if (_pendingRequest.orderType == IGravixVault.LimitOrderType.Stop) {
            isPriceOk = _pendingRequest.positionType == IGravixVault.PositionType.Long
                ? _pendingRequest.triggerPrice > _pendingRequest.assetPrice
                : _pendingRequest.triggerPrice < _pendingRequest.assetPrice;
        }


        if (!isPriceOk) {
            IGravixVault(vault).revert_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _reqNonce,
                _pendingRequest
            );
            return;
        }

        // always trying to get grandReferrer on 1st request if referrer is set
        if (requestCounter == 1 && referrer != address(0)) {
            address referrerAcc = _getGravixAccountAddress(referrer);
            firstLimitRequest = _pendingRequest;
            firstReqNonce = _reqNonce;
            IGravixAccount(referrerAcc).getReferrerForLimitOrder{
                    value: 0, flag: MsgFlag.ALL_NOT_RESERVED, callback: IGravixAccount.process_getLimitReferrer
            }();
            return;
        }

        IGravixVault(vault).finish_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _reqNonce,
            _pendingRequest,
            requestCounter
        );
    }

    function process_executeLimitOrder(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _positionSizeAsset,
        IGravixVault.PositionType _positionType,
        uint128 _assetPrice,
        int256 _accUSDFundingPerShare,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        LimitOrder request = limitOrders[_positionKey];

        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _meta);

            IGravixVault(vault).revert_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                request.collateral,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            return;
        }

        // check if request exists + double check market idx
        if (request.collateral == 0 || request.marketIdx != _marketIdx) {
            IGravixVault(vault).revert_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                0,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            return;
        }


        bool isPriceOk;
        if (request.limitOrderType == IGravixVault.LimitOrderType.Limit) {
            isPriceOk = request.positionType == IGravixVault.PositionType.Long
                ? request.triggerPrice >= _assetPrice
                : request.triggerPrice <= _assetPrice;
        }

        if (request.limitOrderType == IGravixVault.LimitOrderType.Stop) {
            isPriceOk = request.positionType == IGravixVault.PositionType.Long
                ? request.triggerPrice <= _assetPrice
                : request.triggerPrice >= _assetPrice;
        }

        if (!isPriceOk) {
            IGravixVault(vault).revert_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _positionKey,
                _marketIdx,
                request.collateral,
                _positionSizeAsset,
                _assetPrice,
                _positionType,
                _meta
            );
            return;
        }

        delete limitOrders[_positionKey];

        // add base spread
        uint128 openPrice = request.positionType == IGravixVault.PositionType.Long
            ?  math.muldiv(request.triggerPrice, Constants.HUNDRED_PERCENT, Constants.HUNDRED_PERCENT - request.baseSpreadRate)
            :  math.muldiv(request.triggerPrice, Constants.HUNDRED_PERCENT, Constants.HUNDRED_PERCENT + request.baseSpreadRate);

        uint128 leveragedPositionUsd = math.muldiv(request.collateral, request.leverage, Constants.LEVERAGE_BASE);
        uint128 openFee = math.muldiv(leveragedPositionUsd, request.openFeeRate, Constants.HUNDRED_PERCENT);

        Position openedPosition = Position(
            request.marketIdx,
            request.positionType,
            request.collateral,
            openFee,
            openPrice,
            _assetPrice,
            request.leverage,
            _accUSDFundingPerShare,
            request.borrowBaseRatePerHour,
            request.baseSpreadRate,
            request.closeFeeRate,
            request.liquidationThresholdRate,
            now
        );
        positions[_positionKey] = openedPosition;

        IGravixVault(vault).finish_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _positionKey,
            openedPosition,
            referrer,
            grandReferrer,
            _meta
        );
    }

    function process_cancelLimitOrder(
        uint32 _positionKey,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        MarketOrder _request = marketOrders[_positionKey];

        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _meta);
            IGravixVault(vault).revert_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _meta
            );
            return;
        }
        // check request exists
        if (_request.collateral == 0) {
            IGravixVault(vault).revert_cancelLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _meta
            );
            return;
        }

        delete marketOrders[_positionKey];

        IGravixVault(vault).finish_cancelLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, _positionKey, _request.collateral, _meta
        );
    }

    function process_liquidatePositions(
        address _liquidator,
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _assetPrice,
        IGravixVault.Funding _funding,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        Position _position = positions[_positionKey];

        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _meta);

            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _liquidator,
                _positionKey,
                _marketIdx,
                _meta
            );
            return;
        }
        // if collateral == 0, position does not exist
        if (_position.initialCollateral == 0 || _position.marketIdx != _marketIdx) {
            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _liquidator, _positionKey, _marketIdx, _meta
            );
            return;
        }

        PositionView positionView = getPositionView(ViewInput(_positionKey, _assetPrice, _funding));
        if (positionView.liquidate) {
            delete positions[_positionKey];
            IGravixVault(vault).finish_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _liquidator, _positionKey, _assetPrice, positionView,
                referrer, grandReferrer, _meta
            );
        } else {
            IGravixVault(vault).revert_liquidatePositions{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _liquidator, _positionKey, _marketIdx, _meta
            );
        }
    }

    function process_closePosition(
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _assetPrice,
        IGravixVault.Funding _funding,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        Position _position = positions[_positionKey];

        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _meta);

            IGravixVault(vault).revert_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _marketIdx, _meta
            );
            return;
        }
        if (_position.initialCollateral == 0 || _position.marketIdx != _marketIdx) {
            IGravixVault(vault).revert_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _positionKey, _marketIdx, _meta
            );
            return;
        }

        PositionView positionView = getPositionView(ViewInput(_positionKey, _assetPrice, _funding));
        delete positions[_positionKey];

        IGravixVault(vault).finish_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, _positionKey, _assetPrice, positionView,
            referrer, grandReferrer, _meta
        );
    }

    function process_addCollateral(
        uint128 amount,
        uint32 marketIdx,
        uint32 positionKey,
        Callback.CallMeta meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        Position _position = positions[positionKey];

        if  (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, meta);
            IGravixVault(vault).revert_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, amount, marketIdx, positionKey, meta
            );
            return;
        }

        // if collateral == 0, position does not exist
        if (_position.initialCollateral == 0 || _position.marketIdx != marketIdx) {
            IGravixVault(vault).revert_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, amount, marketIdx, positionKey, meta
            );
            return;
        }

        uint128 oldCollateral = _position.initialCollateral - _position.openFee;
        uint128 newCollateral = oldCollateral + amount;
        uint128 leveragedPositionUsd = math.muldiv(oldCollateral, _position.leverage, Constants.LEVERAGE_BASE);
        uint32 newLeverage = uint32(math.muldiv(leveragedPositionUsd, Constants.LEVERAGE_BASE, newCollateral));

        _position.initialCollateral += amount;
        uint32 oldLeverage = _position.leverage;
        _position.leverage = newLeverage;

        positions[positionKey] = _position;

        IGravixVault(vault).finish_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            amount,
            _position,
            oldLeverage,
            positionKey,
            meta
        );
    }

    function process_removeCollateral(
        uint128 _amount,
        uint32 _positionKey,
        uint32 _marketIdx,
        uint32 _maxLeverage,
        uint128 _minCollateral,
        Callback.CallMeta _meta,
        uint32 _accountVersion
    ) external override onlyGravixVault reserve {
        if (_accountVersion != currentVersion) {
            requestUpgrade(user, currentVersion, _meta);
            IGravixVault(vault).revert_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user,
                _amount,
                _positionKey,
                _marketIdx,
                _meta
            );
            return;
        }
        Position _position = positions[_positionKey];
        uint128 oldCollateral = _position.initialCollateral - _position.openFee;

        // math.min because at this point we dont know if position exists
        uint128 newCollateral = oldCollateral - math.min(_amount, oldCollateral);
        uint128 leveragedPositionUsd = math.muldiv(oldCollateral, _position.leverage, Constants.LEVERAGE_BASE);
        // math.max(col, 1) because we dont want to div by 0 if position does not exist
        uint32 newLeverage = uint32(math.muldiv(leveragedPositionUsd, Constants.LEVERAGE_BASE, math.max(newCollateral, 1)));

        // if collateral == 0, position does not exist
        if (
            _position.initialCollateral == 0 ||
            (oldCollateral - math.min(oldCollateral, _amount) < _minCollateral) ||
            _position.marketIdx != _marketIdx ||
            newLeverage > _maxLeverage
        ) {
            IGravixVault(vault).revert_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                user, _amount, _positionKey, _marketIdx, _meta
            );
            return;
        }

        _position.initialCollateral -= _amount;
        uint32 oldLeverage = _position.leverage;
        _position.leverage = newLeverage;

        positions[_positionKey] = _position;

        IGravixVault(vault).finish_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user,
            _amount,
            _position,
            oldLeverage,
            _positionKey,
            _meta
        );
    }

    onBounce(TvmSlice slice) external {
        tvm.accept();

        uint32 functionId = slice.decode(uint32);
        // we can get here because of failed referrer/grand referrer callback
        bool isMarketReferrerRequest = functionId == tvm.functionId(IGravixAccount.getReferrerForLimitOrder);
        bool isLimitReferrerRequest = functionId == tvm.functionId(IGravixAccount.getReferrerForLimitOrder);
        if (isMarketReferrerRequest || isLimitReferrerRequest) {
            tvm.rawReserve(_reserve(), 0);
            if (referrer != address(0) && grandReferrer != address(0)) {
                // If both addresses are set, it means we:
                // 1. Checked that referrer exists and got grand referrer address
                // 2. Tried to check that grand referrer exists and got bounce
                delete grandReferrer;
            } else if (referrer != address(0)) {
                // We tried to check that referrer exists and got bounce
                delete referrer;
            }
            delete firstReqNonce;
            if (isMarketReferrerRequest) {
                IGravixVault(vault).finish_requestMarketOrder{
                        value: 0,
                        flag: MsgFlag.ALL_NOT_RESERVED
                }(firstReqNonce, firstMarketRequest, 1);
                delete firstMarketRequest;
                return;
            }

            if (isLimitReferrerRequest) {
                IGravixVault(vault).finish_requestLimitOrder{
                        value: 0,
                        flag: MsgFlag.ALL_NOT_RESERVED
                }(firstReqNonce, firstLimitRequest, 1);
                delete firstLimitRequest;
                return;
            }
        }
    }
}
