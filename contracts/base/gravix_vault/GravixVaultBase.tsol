pragma ever-solidity ^0.62.0;

import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Gas.tsol";
import "../../libraries/Callback.tsol";
import "../../interfaces/IGravixAccount.tsol";
import "./GravixVaultOrders.tsol";
import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";
import "locklift/src/console.tsol";


abstract contract GravixVaultBase is GravixVaultOrders {
    function transferOwnership(address new_owner, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        owner = new_owner;
        emit NewOwner(meta.call_id, new_owner);
    }

    function setMarketManager(address new_manager, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        marketManager = new_manager;
        emit NewMarketManager(meta.call_id, new_manager);
    }

    function setManager(address new_manager, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        manager = new_manager;
        emit NewManager(meta.call_id, new_manager);
    }

    function setOracle(address new_oracle, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        oracle = new_oracle;
        emit NewOracle(meta.call_id, new_oracle);
    }

    function setPriceNode(address new_node, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        priceNode = new_node;
        emit NewPriceNode(meta.call_id, new_node);
    }

    function setPricePubkey(uint256 new_pubkey, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        pricePubkey = new_pubkey;
        emit NewPricePubkey(meta.call_id, new_pubkey);
    }

    function setPause(bool new_state, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        paused = new_state;
        emit Pause(meta.call_id, new_state);
    }

    function setLiquidationThresholdRate(uint64 new_rate, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        require (new_rate < Constants.HUNDRED_PERCENT, Errors.BAD_INPUT);

        liquidationThresholdRate = new_rate;
        emit LiquidationThresholdRateUpdate(meta.call_id, new_rate);
    }

    function setLiquidatorRewardShare(uint64 new_share, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        require (new_share < Constants.HUNDRED_PERCENT, Errors.BAD_INPUT);

        liquidatorRewardShare = new_share;
        emit LiquidatorRewardShareUpdate(meta.call_id, new_share);
    }

    function setMaxPoolUtilRatio(uint64 new_ratio, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        maxPoolUtilRatio = new_ratio;
        emit MaxPoolUtilRatioUpdate(meta.call_id, new_ratio);
    }

    function setMaxPnlRate(uint64 new_max_rate, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        maxPnlRate = new_max_rate;
        emit MaxPnlRateUpdate(meta.call_id, new_max_rate);
    }

    function setTotalNOILimit(bool new_state, Callback.CallMeta meta) external onlyOwner reserveAndSendGas(meta) {
        totalNOILimitEnabled = new_state;
        emit TotalNOILimit(meta.call_id, new_state);
    }

    function setOpenCloseFeeDistributionSchema(
        uint64[2] new_open_fee_schema, uint64[2] new_close_fee_schema, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        require (new_open_fee_schema[0] + new_open_fee_schema[1] == Constants.HUNDRED_PERCENT, Errors.BAD_INPUT);
        require (new_close_fee_schema[0] + new_close_fee_schema[1] == Constants.HUNDRED_PERCENT, Errors.BAD_INPUT);

        openFeeDistributionSchema = new_open_fee_schema;
        closeFeeDistributionSchema = new_close_fee_schema;

        emit OpenCloseFeeSchemaUpdate(meta.call_id, new_open_fee_schema, new_close_fee_schema);
    }

    function setTreasury(
        address new_treasury, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        treasury = new_treasury;
        emit NewTreasury(meta.call_id, new_treasury);
    }

    function setProjectFund(
        address new_project_fund, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        projectFund = new_project_fund;
        emit NewProjectFund(meta.call_id, new_project_fund);
    }

    function setDevFund(
        address new_dev_fund, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        devFund = new_dev_fund;
        emit NewDevFund(meta.call_id, new_dev_fund);
    }

    function setInsuranceFundLimit(
        uint128 new_limit, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        insuranceFundLimit = new_limit;
        emit InsuranceFundLimitUpdate(meta.call_id, new_limit);
    }

    function setInsuranceFundOverflowDistributionSchema(
        uint64[3] new_schema, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        insuranceFundOverflowDistributionSchema = new_schema;
        emit InsuranceFundOverflowDistributionSchemaUpdate(meta.call_id, new_schema);
    }

    function setReferralFeeSchema(
        uint64[3] new_schema, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        referralFeeSchema = new_schema;
        emit ReferralFeeSchemaUpdate(meta.call_id, new_schema);
    }

    function setMinPositionCollateral(
        uint128 new_val, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        minPositionCollateral = new_val;
        emit MinPositionCollateralUpdate(meta.call_id, new_val);
    }

    function receiveTokenWalletAddress(address wallet) external override {
        if (msg.sender == usdt) usdtWallet = wallet;
        if (msg.sender == stgUsdt) stgUsdtWallet = wallet;
    }

    function onAcceptTokensTransfer(
        address,
        uint128 amount,
        address sender,
        address,
        address remainingGasTo,
        TvmCell payload
    ) external override reserve {
        require (msg.sender == usdtWallet || msg.sender == stgUsdtWallet, Errors.NOT_TOKEN_WALLET);

        (
            Action action,
            uint32 nonce,
            uint32 call_id,
            TvmCell action_payload,
            bool correct
        ) = decodeTokenTransfer(payload);
        bool exception = !correct || paused || msg.value < Gas.MIN_MSG_VALUE;

        if (msg.sender == usdtWallet) {
            if (!exception && action == Action.MarketOrder) {
                exception = exception || !_handleMarketOrder(sender, amount, action_payload, Callback.CallMeta(call_id, nonce, remainingGasTo));
            } else if (!exception && action == Action.LiquidityDeposit) {
                _handleUsdtDeposit(sender, amount, Callback.CallMeta(call_id, nonce, remainingGasTo));
            } else if (!exception && action == Action.InsuranceDeposit) {
                _handleInsuranceDeposit(sender, amount, Callback.CallMeta(call_id, nonce, remainingGasTo));
            } else if (!exception && action == Action.AddCollateral) {
                _handleAddCollateral(sender, amount, action_payload, Callback.CallMeta(call_id, nonce, remainingGasTo));
            } else {
                // bad action for USDT
                exception = true;
            }
        } else if (msg.sender == stgUsdtWallet) {
            if (!exception && action == Action.LiquidityWithdraw) {
                _handleStgUsdtDeposit(sender, amount, Callback.CallMeta(call_id, nonce, remainingGasTo));
            } else {
                // bad action for stgUSDT
                exception = true;
            }
        }

        if (exception) {
            emit ActionRevert(call_id, sender);
            // if payload assembled correctly, send nonce, otherwise send payload we got with this transfer
            payload = correct ? _makeCell(nonce) : payload;
            _transfer(msg.sender, amount, sender, payload, remainingGasTo, MsgFlag.ALL_NOT_RESERVED);
        }
    }

    function onAcceptTokensBurn(
        uint128 amount,
        address,
        address wallet,
        address,
        TvmCell payload
    ) external override reserve {
        require (wallet == stgUsdtWallet, Errors.NOT_TOKEN_WALLET);
        require (msg.sender == stgUsdt, Errors.NOT_TOKEN_ROOT);

        _handleStgUsdtBurn(amount, payload);
    }

    onBounce(TvmSlice slice) external {
        tvm.accept();

        uint32 functionId = slice.decode(uint32);

        // if processing failed - contract was not deployed. Deploy and try again
        if (functionId == tvm.functionId(IGravixAccount.process_requestMarketOrder)) {
            tvm.rawReserve(_reserve(), 0);
            uint32 _request_nonce = slice.decode(uint32);
            PendingMarketOrder request = pending_market_requests[_request_nonce];
            delete pending_market_requests[_request_nonce];

            address gravix_acc = _deployGravixAccount(request.user, request.referrer);
            IGravixAccount(gravix_acc).process_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                _request_nonce, request
            );
        }
    }
}
