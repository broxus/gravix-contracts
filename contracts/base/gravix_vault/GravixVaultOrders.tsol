pragma ever-solidity ^0.62.0;



import "broxus-token-contracts/contracts/interfaces/ITokenRootUpgradeable.tsol";
import "broxus-token-contracts/contracts/interfaces/ITokenWalletUpgradeable.tsol";
import "broxus-token-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Gas.tsol";
import "../../libraries/Callback.tsol";
import "../../interfaces/IGravixAccount.tsol";
import "../../interfaces/IOracleProxy.tsol";
import "./GravixVaultMarkets.tsol";
import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";
import "locklift/src/console.tsol";



abstract contract GravixVaultOrders is GravixVaultMarkets {
    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER REQUEST HANDLERS -------------------------------
    // ----------------------------------------------------------------------------------
    function _handleMarketOrder(
        address user, uint128 collateral, TvmCell order_params_payload, Callback.CallMeta meta
    ) internal returns (bool success) {
        (
            uint32 market_idx,
            PositionType position_type,
            uint32 leverage,
            uint128 expected_price,
            uint64 max_slippage_rate,
            IEthereumEvent.EthereumEventOracleData event_data,
            OffchainPrice price
        ) = decodeMarketOrderPayload(order_params_payload);

        // collateral has USDT decimals -> 6
        // price has PRICE decimals -> 8
        if (!validateOrderParams(market_idx, collateral, leverage, max_slippage_rate)) return false;
        if (checkPositionAllowed(
            market_idx,
            collateral,
            leverage,
            expected_price,
            position_type) > 0
        ) return false;
        if (!marketOpen(market_idx)) return false;
        _marketOrder(
            user, market_idx, position_type, collateral, leverage, expected_price, max_slippage_rate, event_data, price, meta
        );
        return true;
    }

    // @param market_idx - market id
    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param max_slippage - max order price slippage, percent number, 10**12 - 100%
    function validateOrderParams(uint32 market_idx, uint128 collateral, uint32 leverage, uint64 max_slippage) public view returns (bool correct) {
        if (collateral < minPositionCollateral) return false;
        if (!markets.exists(market_idx)) return false;
        if (leverage > markets[market_idx].maxLeverage) return false;
        if (max_slippage > HUNDRED_PERCENT) return false;
        return true;
    }

    // @param user - order maker
    // @param market_idx - market id
    // @param position_type - 0 - long, 1 - short
    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param max_slippage_rate - max order price slippage, percent number, 10**12 - 100%
    // @param event_data - EVM chain event data, required for chainlink proxy price feeds
    // @param meta - meta info of txn
    function _marketOrder(
        address user,
        uint32 market_idx,
        PositionType position_type,
        uint128 collateral,
        uint32 leverage,
        uint128 expected_price,
        uint64 max_slippage_rate, // %
        IEthereumEvent.EthereumEventOracleData event_data,
        OffchainPrice price,
        Callback.CallMeta meta
    ) internal {
        Market _market = markets[market_idx];
        request_nonce += 1;

        PendingMarketOrder new_request = PendingMarketOrder(
            user,
            market_idx,
            position_type,
            collateral,
            expected_price,
            leverage,
            max_slippage_rate,
            _market.fees.openFeeRate,
            _market.fees.closeFeeRate,
            _market.fees.baseSpreadRate,
            liquidationThresholdRate,
            _market.fees.borrowBaseRatePerHour,
            event_data,
            price,
            meta
        );

        pending_market_requests[request_nonce] = new_request;
        address gravix_acc = getGravixAccountAddress(user);
        IGravixAccount(gravix_acc).process_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(request_nonce, new_request);
    }

    function finish_requestMarketOrder(
        PendingMarketOrder request,
        uint32 position_key
    ) external override onlyGravixAccount(request.user) reserve {
        collateralReserve += request.collateral;

        emit MarketOrder(
            request.meta.call_id,
            request.user,
            request.marketIdx,
            request.positionType,
            request.collateral,
            request.expectedPrice,
            request.leverage,
            request.maxSlippageRate,
            position_key
        );

        OracleType price_source = markets[request.marketIdx].priceSource;
        OracleConfig oracle_conf = oracleConfigs[request.marketIdx];

        // if market uses offchain oracle and we have valid price, we can execute order right now
        if (price_source == OracleType.PriceNode && checkPrice(request.price, oracle_conf.priceNode)) {
            _executeOrder(
                request.user,
                position_key,
                request.marketIdx,
                request.collateral,
                request.leverage,
                request.positionType,
                request.price.price,
                request.meta
            );
            return;
        }

        _sendOpenOrderOracleRequest(
            request.user,
            position_key,
            request.marketIdx,
            request.collateral,
            request.leverage,
            request.positionType,
            request.eventData,
            request.meta
        );
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- ORACLE REQUEST ---------------------------------------
    // ----------------------------------------------------------------------------------
    function _sendOpenOrderOracleRequest(
        address user,
        uint32 position_key,
        uint32 market_idx,
        uint128 collateral,
        uint32 leverage,
        PositionType position_type,
        IEthereumEvent.EthereumEventOracleData event_data,
        Callback.CallMeta meta
    ) internal view {
        address proxy = _deployOracleProxy(market_idx, event_data, meta);
        IOracleProxy(proxy).setExecuteCallback{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(user, position_key, collateral, leverage, position_type);
    }

    function _sendCloseOrderOracleRequest(
        address user,
        uint32 position_key,
        uint32 market_idx,
        IEthereumEvent.EthereumEventOracleData event_data,
        Callback.CallMeta meta
    ) internal view {
        address proxy = _deployOracleProxy(market_idx, event_data, meta);
        IOracleProxy(proxy).setCloseCallback{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(user, position_key);
    }

    function _sendLiquidationOracleRequest(
        address liquidator,
        uint32 market_idx,
        PositionIdx[] positions,
        IEthereumEvent.EthereumEventOracleData event_data,
        Callback.CallMeta meta
    ) internal view {
        address proxy = _deployOracleProxy(market_idx, event_data, meta);
        uint128 callback_value = uint128(positions.length) * Gas.LIQUIDATION_VALUE;
        IOracleProxy(proxy).setLiquidationCallback{value: callback_value, flag: MsgFlag.SENDER_PAYS_FEES}(liquidator, positions);
    }

    function _deployOracleProxy(
        uint32 market_idx, IEthereumEvent.EthereumEventOracleData event_data, Callback.CallMeta meta
    ) internal view returns (address) {
        OracleType price_source = markets[market_idx].priceSource;
        OracleConfig oracle_conf = oracleConfigs[market_idx];

        emit OraclePriceRequested(meta.call_id, market_idx);
        // update random seed
        rnd.shuffle();
        return new OracleProxy{
            stateInit: _buildOracleProxyInitData(rnd.next(uint64(2**64 - 1))),
            value: Gas.ORACLE_PROXY_DEPLOY
        }(
            usdt, priceNode, oracle, market_idx, price_source, oracle_conf, event_data, meta
        );
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER EXECUTE HANDLERS -------------------------------
    // ----------------------------------------------------------------------------------
    // @param nonce - oracle static parameter, required for addr calculation
    // @param user - order maker
    // @param position_key - unique(per user) position key
    // @param market_idx - market id
    // @param collateral - position collateral, 6 decimals number
    // @param leverage - position leverage, 2 decimals number
    // @param position_type - 0 - long, 1 - short
    // @param asset_price - current asset price for this market, 8 decimals number
    // @param meta - txn meta
    function oracle_executeMarketOrder(
        uint64 nonce,
        address user,
        uint32 position_key,
        uint32 market_idx,
        uint128 collateral,
        uint32 leverage,
        PositionType position_type,
        uint128 asset_price,
        Callback.CallMeta meta
    ) external override onlyOracleProxy(nonce) reserve {
        _executeOrder(
            user,
            position_key,
            market_idx,
            collateral,
            leverage,
            position_type,
            asset_price,
            meta
        );
    }

    function _executeOrder(
        address user,
        uint32 position_key,
        uint32 market_idx,
        uint128 collateral,
        uint32 leverage,
        PositionType position_type,
        uint128 asset_price,
        Callback.CallMeta meta
    ) internal {
        // reserve should be
        uint128 position_size_asset = calculatePositionAssetSize(collateral, leverage, asset_price);
        uint64 dynamic_spread = getDynamicSpread(position_size_asset, market_idx, position_type);

        Funding _funding = _updateFunding(market_idx, asset_price);
        uint16 _error = _addPositionToMarketOrReturnErr(market_idx, position_size_asset, asset_price, position_type);

        address gravix_acc = getGravixAccountAddress(user);
        if (_error == 0) {
            int256 funding = position_type == PositionType.Long ? _funding.accLongUSDFundingPerShare : _funding.accShortUSDFundingPerShare;

            IGravixAccount(gravix_acc).process_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                position_key,
                market_idx,
                position_size_asset,
                position_type,
                asset_price,
                dynamic_spread,
                funding,
                meta
            );
        } else {
            // order cant be executed now, some limits reached and etc.
            IGravixAccount(gravix_acc).process_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(position_key, meta);
        }
    }

    function revert_executeMarketOrder(
        address user,
        uint32 position_key,
        uint32 market_idx,
        uint128 collateral,
        uint128 position_size_asset,
        uint128 asset_price,
        PositionType position_type,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        emit MarketOrderExecutionRevert(meta.call_id, user, position_key);

        _removePositionFromMarket(market_idx, position_size_asset, asset_price, position_type);

        // too high slippage
        if (collateral > 0) {
            collateralReserve -= collateral;
            _transfer(
                usdtWallet, collateral, user, _makeCell(meta.nonce), meta.send_gas_to, MsgFlag.ALL_NOT_RESERVED
            );
        } else {
            // tried to execute non-existent order
            _sendCallbackOrGas(user, meta.nonce, false, meta.send_gas_to);
        }
    }

    function finish_executeMarketOrder(
        address user,
        uint32 position_key,
        IGravixAccount.Position new_pos,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserveAndSuccessCallback(meta) {
        _collectOpenFee(new_pos.openFee);
        collateralReserve -= new_pos.openFee;

        uint128 position_size_asset_raw = calculatePositionAssetSize(new_pos.initialCollateral, new_pos.leverage, new_pos.markPrice);
        _removePositionFromMarket(new_pos.marketIdx, position_size_asset_raw, new_pos.markPrice, new_pos.positionType);

        uint128 position_size_asset = calculatePositionAssetSize(new_pos.initialCollateral - new_pos.openFee, new_pos.leverage, new_pos.openPrice);
        _addPositionToMarket(new_pos.marketIdx, position_size_asset, new_pos.markPrice, new_pos.positionType);

        emit MarketOrderExecution(
            meta.call_id,
            user,
            new_pos,
            position_key
        );
    }

    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param asset_price - position price, 8 decimals number
    function calculatePositionAssetSize(uint128 collateral, uint32 leverage, uint128 asset_price) public pure returns (uint128 position_size_asset) {
        return math.muldiv(math.muldiv(collateral, leverage, LEVERAGE_BASE), PRICE_DECIMALS, asset_price);
    }

    function getDynamicSpread(
        uint128 position_size_asset,
        uint32 market_idx,
        PositionType position_type
    ) public view responsible returns (uint64 dynamic_spread) {
        uint128 new_noi;

        Market market = markets[market_idx];
        // calculate dynamic dynamic_spread multiplier
        if (position_type == PositionType.Long) {
            uint128 new_longs_total = market.totalLongsAsset + position_size_asset / 2;
            new_noi = new_longs_total - math.min(market.totalShortsAsset, new_longs_total);
        } else {
            uint128 new_shorts_total = market.totalShortsAsset + position_size_asset / 2;
            new_noi = new_shorts_total - math.min(market.totalLongsAsset, new_shorts_total);
        }
        dynamic_spread = uint64(math.muldiv(new_noi, market.fees.baseDynamicSpreadRate, market.depthAsset));
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } dynamic_spread;
    }
    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER CANCEL HANDLERS --------------------------------
    // ----------------------------------------------------------------------------------
    function cancelMarketOrder(address user, uint32 position_key, Callback.CallMeta meta) external view onlyActive reserve {
        require (msg.value >= Gas.MIN_MSG_VALUE, Errors.LOW_MSG_VALUE);

        address gravix_acc = getGravixAccountAddress(user);
        IGravixAccount(gravix_acc).process_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(position_key, meta);
    }

    function revert_cancelMarketOrder(
        address user, uint32 position_key, Callback.CallMeta meta
    ) external view override onlyGravixAccount(user) reserveAndFailCallback(meta) {
        emit CancelMarketOrderRevert(meta.call_id, user, position_key);
    }

    function finish_cancelMarketOrder(
        address user, uint32 position_key, uint128 collateral, Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        collateralReserve -= collateral;

        emit CancelMarketOrder(meta.call_id, user, position_key);
        _transfer(usdtWallet, collateral, user, _makeCell(meta.nonce), meta.send_gas_to, MsgFlag.ALL_NOT_RESERVED);
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER CLOSE HANDLERS ---------------------------------
    // ----------------------------------------------------------------------------------
    function forceClosePositions(
        address[] users,
        uint32[] position_keys,
        IEthereumEvent.EthereumEventOracleData[] event_datas,
        OffchainPrice[] prices,
        Callback.CallMeta meta
    ) external view onlyOwner reserveAndSendGas(meta) {
        require (users.length == position_keys.length, Errors.BAD_INPUT);
        require (msg.value >= Gas.MIN_MSG_VALUE * users.length, Errors.LOW_MSG_VALUE);

        for (uint i = 0; i < users.length; i++) {
            address gravix_acc = getGravixAccountAddress(users[i]);
            IGravixAccount(gravix_acc).process_closePosition{value: Gas.MIN_MSG_VALUE - 0.1 ever}(
                position_keys[i], event_datas[i], prices[i], meta
            );
        }
    }

    // @notice Should be used by admin very carefully when oracle is dead by some reason to save users
    function forceClosePositionsWithPrice(
        address[] users, uint32[] position_keys, uint32[] market_idx, uint128[] asset_prices, Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        require (users.length == position_keys.length, Errors.BAD_INPUT);
        require (position_keys.length == market_idx.length, Errors.BAD_INPUT);
        require (market_idx.length == asset_prices.length, Errors.BAD_INPUT);
        require (msg.value >= Gas.MIN_MSG_VALUE * users.length, Errors.LOW_MSG_VALUE);

        for (uint i = 0; i < users.length; i++) {
            Funding _funding = _updateFunding(market_idx[i], asset_prices[i]);

            address gravix_acc = getGravixAccountAddress(users[i]);
            IGravixAccount(gravix_acc).process2_closePosition{value: Gas.MIN_MSG_VALUE - 0.1 ever}(
                position_keys[i],
                asset_prices[i],
                _funding,
                meta
            );
        }
    }

    function closePosition(
        uint32 position_key, IEthereumEvent.EthereumEventOracleData event_data, OffchainPrice price, Callback.CallMeta meta
    ) external view onlyActive reserve {
        require (msg.value >= Gas.MIN_MSG_VALUE, Errors.LOW_MSG_VALUE);

        address gravix_acc = getGravixAccountAddress(msg.sender);
        IGravixAccount(gravix_acc).process_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            position_key, event_data, price, meta
        );
    }

    function process1_closePosition(
        address user,
        uint32 position_key,
        uint32 market_idx,
        IEthereumEvent.EthereumEventOracleData event_data,
        OffchainPrice price,
        Callback.CallMeta meta
    ) external override reserve {
        // soft fail
        if (!marketOpen(market_idx)) {
            emit ClosePositionRevert(meta.call_id, user, position_key);
            _sendCallbackOrGas(user, meta.nonce, false, meta.send_gas_to);
            return;
        }

        OracleType price_source = markets[market_idx].priceSource;
        OracleConfig oracle_conf = oracleConfigs[market_idx];

        // if market uses offchain oracle and we have valid price, we can close order right now
        if (price_source == OracleType.PriceNode && checkPrice(price, oracle_conf.priceNode)) {
            _closePosition(user, position_key, market_idx, price.price, meta);
            return;
        }

        _sendCloseOrderOracleRequest(user, position_key, market_idx, event_data, meta);
    }

    // @param nonce - oracle static parameter, required for addr calculation
    // @param user - order maker
    // @param position_key - unique(per user) position key
    // @param market_idx - market id
    // @param asset_price - current asset price for this market, 8 decimals number
    // @param meta - txn meta
    function oracle_closePosition(
        uint64 nonce,
        address user,
        uint32 position_key,
        uint32 market_idx,
        uint128 asset_price,
        Callback.CallMeta meta
    ) external override onlyOracleProxy(nonce) reserve {
        _closePosition(user, position_key, market_idx, asset_price, meta);
    }

    function _closePosition(
        address user,
        uint32 position_key,
        uint32 market_idx,
        uint128 asset_price,
        Callback.CallMeta meta
    ) internal {
        Funding _funding = _updateFunding(market_idx, asset_price);
        address gravix_acc = getGravixAccountAddress(user);
        IGravixAccount(gravix_acc).process2_closePosition{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            position_key,
            asset_price,
            _funding,
            meta
        );
    }

    function revert_closePosition(
        address user, uint32 position_key, Callback.CallMeta meta
    ) external view override onlyGravixAccount(user) reserveAndFailCallback(meta) {
        emit ClosePositionRevert(meta.call_id, user, position_key);
    }

    function finish_closePosition(
        address user, uint32 position_key, uint128 asset_price, IGravixAccount.PositionView position_view, Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        // we already deducted open fee when position was opened
        uint128 collateral = position_view.position.initialCollateral - position_view.position.openFee;
        collateralReserve -= collateral;

        uint128 initial_position_size_asset = calculatePositionAssetSize(collateral, position_view.position.leverage, position_view.position.openPrice);
        _removePositionFromMarket(
            position_view.position.marketIdx,
            initial_position_size_asset,
            asset_price,
            position_view.position.positionType
        );

        if (position_view.liquidate) {
            _increaseInsuranceFund(collateral);

            emit LiquidatePosition(meta.call_id, user, user, position_key, position_view);
            _sendCallbackOrGas(user, meta.nonce, true, meta.send_gas_to);
        } else {
            int256 pnl_with_fees = position_view.pnl - position_view.borrowFee - position_view.fundingFee;
            _collectCloseFee(position_view.closeFee);

            uint128 debt;
            if (pnl_with_fees < 0) _increaseInsuranceFund(uint128(math.abs(pnl_with_fees)));
            if (pnl_with_fees > 0) {
                // positive debt if we dont have enough money to pay pnl
                debt = _decreaseInsuranceFund(uint128(pnl_with_fees));
            }

            emit ClosePosition(meta.call_id, user, position_key, position_view);

            if (debt > 0) {
                // at least we can pay collateral, because it was reserved
                uint128 user_net_usdt = collateral - position_view.closeFee;
                _transfer(usdtWallet, user_net_usdt , user, _makeCell(meta.nonce), meta.send_gas_to, MsgFlag.ALL_NOT_RESERVED);
                emit Debt(meta.call_id, user, uint128(pnl_with_fees));
            } else {
                // we know for sure collateral > pnl and fee, otherwise position would have been liquidated
                uint128 user_net_usdt = uint128(collateral + pnl_with_fees - position_view.closeFee);
                _transfer(usdtWallet, user_net_usdt, user, _makeCell(meta.nonce), meta.send_gas_to, MsgFlag.ALL_NOT_RESERVED);
            }
        }
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- LIQUIDATION ------------------------------------------
    // ----------------------------------------------------------------------------------
    // @notice 3 ever for every market + 1 ever for every position
    // @dev Aggregate by market to minimize requests to oracle
    function liquidatePositions(
        mapping (uint32 => LiquidationData) liquidations, Callback.CallMeta meta
    ) external view onlyActive reserveAndSendGas(meta) {
        // dont spend gas to check msg.value, it will fail with 37 code anyway if user didnt send enough, because we use exact values here
        for ((uint32 market_idx, LiquidationData liq_data) : liquidations) {
            require (liq_data.positions.length <= 250, Errors.BAD_INPUT); // we dont want to fail on action phase later

            OracleType price_source = markets[market_idx].priceSource;
            OracleConfig oracle_conf = oracleConfigs[market_idx];

            // if market uses offchain oracle and we have valid price, we can liquidate positions right now
            if (price_source == OracleType.PriceNode && checkPrice(liq_data.price, oracle_conf.priceNode)) {
                uint128 value = uint128(liq_data.positions.length * Gas.LIQUIDATION_VALUE) + Gas.ORACLE_PROXY_DEPLOY;
                this.self_liquidatePositions{value: value}(msg.sender, market_idx, liq_data.positions, liq_data.price.price, meta);
                return;
            }

            _sendLiquidationOracleRequest(msg.sender, market_idx, liq_data.positions, liq_data.eventData, meta);
        }
    }

    function revert_liquidatePositions(
        address user, address liquidator, uint32 position_key, Callback.CallMeta meta
    ) external view override onlyGravixAccount(user) reserveAndFailCallback(meta) {
        emit LiquidatePositionRevert(meta.call_id, liquidator, user, position_key);
    }

    function oracle_liquidatePositions(
        uint64 nonce, address liquidator, uint32 market_idx, PositionIdx[] positions, uint128 asset_price, Callback.CallMeta meta
    ) external override onlyOracleProxy(nonce) reserveAndSendGas(meta) {
        _liquidatePositions(liquidator, market_idx, positions, asset_price, meta);
    }

    function self_liquidatePositions(
        address liquidator, uint32 market_idx, PositionIdx[] positions, uint128 asset_price, Callback.CallMeta meta
    ) external reserveAndSendGas(meta) {
        require (msg.sender == address(this), Errors.BAD_SENDER);
        _liquidatePositions(liquidator, market_idx, positions, asset_price, meta);
    }

    function _liquidatePositions(
        address liquidator, uint32 market_idx, PositionIdx[] positions, uint128 asset_price, Callback.CallMeta meta
    ) internal {
        Funding _funding = _updateFunding(market_idx, asset_price);
        for (PositionIdx position: positions) {
            address gravix_acc = getGravixAccountAddress(position.user);
            // reserve 0.01 ever here to cover computation costs of iterating, needed for big arrays
            IGravixAccount(gravix_acc).process_liquidatePositions{value: Gas.LIQUIDATION_VALUE - 0.01 ever}(
                liquidator,
                position.positionKey,
                asset_price,
                _funding,
                meta
            );
        }
    }

    function finish_liquidatePositions(
        address user,
        address liquidator,
        uint32 position_key,
        uint128 asset_price,
        IGravixAccount.PositionView position_view,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        // we already deducted open fee when position was opened
        uint128 collateral = position_view.position.initialCollateral - position_view.position.openFee;
        collateralReserve -= collateral;

        // we added exactly this amount when opened order
        uint128 initial_position_size_asset = calculatePositionAssetSize(collateral, position_view.position.leverage, position_view.position.openPrice);
        _removePositionFromMarket(
            position_view.position.marketIdx,
            initial_position_size_asset,
            asset_price,
            position_view.position.positionType
        );

        uint128 liquidator_reward = math.muldiv(collateral, liquidatorRewardShare, HUNDRED_PERCENT);

        _increaseInsuranceFund(collateral - liquidator_reward);

        emit LiquidatePosition(meta.call_id, user, liquidator, position_key, position_view);

        _transfer(usdtWallet, liquidator_reward, liquidator, _makeCell(meta.nonce), meta.send_gas_to, MsgFlag.SENDER_PAYS_FEES);
        _sendCallbackOrGas(user, meta.nonce, true, meta.send_gas_to);
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- POSITION LIMITS --------------------------------------
    // ----------------------------------------------------------------------------------
    // @param market_idx - market id
    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param asset_price - position price, 8 decimals number
    // @param position_type - 0 - long, 1 - short
    function checkPositionAllowed(
        uint32 market_idx,
        uint128 collateral,
        uint32 leverage,
        uint128 asset_price,
        PositionType position_type
    ) public view returns (uint16) {
        uint128 position_size_asset = calculatePositionAssetSize(collateral, leverage, asset_price);
        (,,uint16 _error) = _calculatePositionImpactAndCheckAllowed(market_idx, position_size_asset, asset_price, position_type);
        return _error;
    }

    function _marketNOI(Market _market) internal pure returns (uint128) {
        return _market.totalLongsAsset > _market.totalShortsAsset ?
            _market.totalLongsAsset - _market.totalShortsAsset :
            _market.totalShortsAsset - _market.totalLongsAsset;
    }

    // @dev Will not apply changes if _error > 0
    // @param market_idx - market id
    // @param position_size_asset - position value in asset, 6 decimals number
    // @param cur_asset_price - position price, 8 decimals number
    // @param position_type - 0 - long, 1 - short
    function _addPositionToMarketOrReturnErr(
        uint32 market_idx, uint128 position_size_asset, uint128 cur_asset_price, PositionType position_type
    ) internal returns (uint16) {
        (
            Market _market,
            uint128 _totalNOI,
            uint16 _error
        ) = _calculatePositionImpactAndCheckAllowed(market_idx, position_size_asset, cur_asset_price, position_type);
        if (_error == 0) {
            markets[market_idx] = _market;
            totalNOI = _totalNOI;
        }
        return _error;
    }

    // @param market_idx - market id
    // @param position_size_asset - position value in asset, 6 decimals number
    // @param cur_asset_price - position price, 8 decimals number
    // @param position_type - 0 - long, 1 - short
    function _calculatePositionImpactAndCheckAllowed(
        uint32 market_idx,
        uint128 position_size_asset,
        uint128 cur_asset_price,
        PositionType position_type
    ) internal view returns (Market _market, uint128 _totalNOI, uint16 _error) {
        (_market, _totalNOI) = _calculatePositionImpact(market_idx, position_size_asset, cur_asset_price, position_type, false);

        uint128 shorts_usd = math.muldiv(_market.totalShortsAsset, cur_asset_price, PRICE_DECIMALS);
        uint128 longs_usd = math.muldiv(_market.totalLongsAsset, cur_asset_price, PRICE_DECIMALS);
        // market limits
        if (shorts_usd > _market.maxTotalShortsUSD || longs_usd > _market.maxTotalLongsUSD) _error = Errors.MARKET_POSITIONS_LIMIT_REACHED;
        // common platform limit
        if (totalNOILimitEnabled && math.muldiv(poolBalance, maxPoolUtilRatio, HUNDRED_PERCENT) < _totalNOI) _error = Errors.PLATFORM_POSITIONS_LIMIT_REACHED;
        return (_market, _totalNOI, _error);
    }

    // @param market_idx - market id
    // @param position_size_asset - position value in asset, 6 decimals number
    // @param cur_asset_price - asset price on moment of update, required for TNOI calculation, 8 decimals number
    // @param position_type - 0 - long, 1 - short
    // @param bool - whether position is removed or added
    function _calculatePositionImpact(
        uint32 market_idx, uint128 position_size_asset, uint128 cur_asset_price, PositionType position_type, bool remove
    ) internal view returns (Market _market, uint128 _totalNOI) {
        _market = markets[market_idx];
        _totalNOI = totalNOI;

        uint128 noi_asset_before = _marketNOI(_market);
        uint128 noi_usd_before = math.muldiv(noi_asset_before, _market.lastNoiUpdatePrice, PRICE_DECIMALS);

        if (position_type == PositionType.Long) {
            _market.totalLongsAsset = remove ? (_market.totalLongsAsset - position_size_asset) : (_market.totalLongsAsset + position_size_asset);
        } else {
            _market.totalShortsAsset = remove ? (_market.totalShortsAsset - position_size_asset) : (_market.totalShortsAsset + position_size_asset);
        }

        uint128 noi_asset_after = _marketNOI(_market);
        uint128 noi_usd_after = math.muldiv(noi_asset_after, cur_asset_price, PRICE_DECIMALS);

        _totalNOI -= math.muldiv(noi_usd_before, _market.noiWeight, WEIGHT_BASE);
        _totalNOI += math.muldiv(noi_usd_after, _market.noiWeight, WEIGHT_BASE);

        _market.lastNoiUpdatePrice = cur_asset_price;
    }


    // @param cur_asset_price - asset price on moment of update, required for TNOI calculation, 8 decimals number
    function _addPositionToMarket(uint32 market_idx, uint128 position_size_asset, uint128 cur_asset_price, PositionType position_type) internal {
        (
            markets[market_idx],
            totalNOI
        ) = _calculatePositionImpact(market_idx, position_size_asset, cur_asset_price, position_type, false);
    }

    // @param cur_asset_price - asset price on moment of update, required for TNOI calculation, 8 decimals number
    function _removePositionFromMarket(uint32 market_idx, uint128 position_size_asset, uint128 cur_asset_price, PositionType position_type) internal {
        (
            markets[market_idx],
            totalNOI
        ) = _calculatePositionImpact(market_idx, position_size_asset, cur_asset_price, position_type, true);
    }
    // ----------------------------------------------------------------------------------
    // --------------------------- FUNDING ----------------------------------------------
    // ----------------------------------------------------------------------------------
    // @param market_idx - market id
    // @param asset_price - asset price, 8 decimals number
    function _updateFunding(uint32 market_idx, uint128 asset_price) internal returns (Funding funding) {
        Market _market = markets[market_idx];
        if (_market.lastFundingUpdateTime == 0) _market.lastFundingUpdateTime = now;

        _market.funding = _getUpdatedFunding(_market, asset_price);
        _market.lastFundingUpdateTime = now;

        markets[market_idx] = _market;
        return _market.funding;
    }

    // TODO: function for updating funding without real deal

    function getUpdatedFunding(mapping (uint32 => uint128) prices) external view returns (mapping (uint32 => Funding) funding) {
        for ((uint32 market_idx, uint128 asset_price): prices) {
            funding[market_idx] = _getUpdatedFunding(markets[market_idx], asset_price);
        }
        return funding;
    }

    function _getUpdatedFunding(Market _market, uint128 asset_price) internal pure returns (Funding _funding) {
        if (_market.lastFundingUpdateTime == 0) _market.lastFundingUpdateTime = now;
        (int128 long_rate_per_hour, int128 short_rate_per_hour) = _getFundingRates(_market);

        _funding.accLongUSDFundingPerShare = _market.funding.accLongUSDFundingPerShare + _calculateFunding(long_rate_per_hour, _market.totalLongsAsset, asset_price, _market.lastFundingUpdateTime);
        _funding.accShortUSDFundingPerShare = _market.funding.accShortUSDFundingPerShare + _calculateFunding(short_rate_per_hour, _market.totalShortsAsset, asset_price, _market.lastFundingUpdateTime);
        return _funding;
    }

    // @param asset_price - asset price, 8 decimals number
    function _calculateFunding(int256 rate_per_hour, uint128 total_position, uint128 asset_price, uint32 last_update_time) internal pure returns (int256) {
        if (rate_per_hour == 0 || total_position == 0) return 0;
        // multiply by SCALING FACTOR in the beginning to prevent precision loss
        int256 funding_asset = math.muldiv(rate_per_hour * SCALING_FACTOR, total_position, HUNDRED_PERCENT);
        funding_asset = math.muldiv(funding_asset, (now - last_update_time), HOUR);
        int256 funding_usd = math.muldiv(funding_asset, asset_price, PRICE_DECIMALS);
        return funding_usd / total_position;
    }

    // @notice returned rates are multiplied by 10**12, e.g 100% = 1_000_000_000_000
    function getFundingRates(uint32 market_idx) public view returns (int128 long_rate_per_hour, int128 short_rate_per_hour) {
        return _getFundingRates(markets[market_idx]);
    }

    // @notice If rate is positive - trader should pay, negative - receive payment
    function _getFundingRates(Market _market) internal pure returns (int128 long_rate_per_hour, int128 short_rate_per_hour) {
        uint128 noi = uint128(math.abs(int256(_market.totalLongsAsset) - _market.totalShortsAsset));
        uint128 funding_rate_per_hour = math.muldiv(
            _market.fees.fundingBaseRatePerHour,
            math.muldiv(noi, SCALING_FACTOR, _market.depthAsset),
            SCALING_FACTOR
        );

        if (_market.totalLongsAsset >= _market.totalShortsAsset) {
            long_rate_per_hour = int128(funding_rate_per_hour);
            if (_market.totalShortsAsset > 0) {
                short_rate_per_hour = -1 * int128(math.muldiv(funding_rate_per_hour, _market.totalLongsAsset, _market.totalShortsAsset));
            }
        } else {
            short_rate_per_hour = int128(funding_rate_per_hour);
            if (_market.totalLongsAsset > 0) {
                long_rate_per_hour = -1 * int128(math.muldiv(funding_rate_per_hour, _market.totalShortsAsset, _market.totalLongsAsset));
            }
        }
        return (long_rate_per_hour, short_rate_per_hour);
    }
}
