pragma ever-solidity ^0.62.0;



import "@broxus/tip3/contracts/interfaces/ITokenRootUpgradeable.tsol";
import "@broxus/tip3/contracts/interfaces/ITokenWalletUpgradeable.tsol";
import "@broxus/tip3/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Gas.tsol";
import "../../libraries/Callback.tsol";
import "../../interfaces/IGravixAccount.tsol";
import "../../interfaces/IOracleProxy.tsol";
import "./GravixVaultMarkets.tsol";
import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";
import "locklift/src/console.tsol";


abstract contract GravixVaultOrders is GravixVaultMarkets {
    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER REQUEST HANDLERS -------------------------------
    // ----------------------------------------------------------------------------------
    function _handleMarketOrder(
        address user, uint128 collateral, TvmCell orderParamsPayload, Callback.CallMeta meta
    ) internal returns (bool success) {
        (
            uint32 marketIdx,
            PositionType positionType,
            uint32 leverage,
            uint128 expectedPrice,
            uint64 maxSlippageRate,
            IPriceNode.Price price,
            address referrer
        ) = decodeMarketOrder(orderParamsPayload);

        // collateral has USDT decimals -> 6
        // price has PRICE decimals -> 8
        if (!validateOrderParams(marketIdx, collateral, leverage, maxSlippageRate)) return false;
        if (checkPositionAllowed(
            marketIdx,
            collateral,
            leverage,
            expectedPrice,
            positionType) > 0
        ) return false;
        if (!marketOpen(marketIdx)) return false;
        _marketOrder(
            user, marketIdx, positionType,
            collateral, leverage, expectedPrice,
            maxSlippageRate, price,
            referrer, meta
        );
        return true;
    }

    // @param marketIdx - market id
    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param maxSlippage - max order price slippage, percent number, 10**12 - 100%
    function validateOrderParams(uint32 marketIdx, uint128 collateral, uint32 leverage, uint64 maxSlippage) public view returns (bool correct) {
        if (collateral < minPositionCollateral) return false;
        if (!markets.exists(marketIdx)) return false;
        if (leverage > markets[marketIdx].maxLeverage) return false;
        if (maxSlippage > Constants.HUNDRED_PERCENT) return false;
        return true;
    }

    // @param user - order maker
    // @param marketIdx - market id
    // @param positionType - 0 - long, 1 - short
    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param maxSlippageRate - max order price slippage, percent number, 10**12 - 100%
    // @param eventData - EVM chain event data, required for chainlink proxy price feeds
    // @param price - price with signature, required for offchain price feeds
    // @param referrer - referrer address
    // @param meta - meta info of txn
    function _marketOrder(
        address user,
        uint32 marketIdx,
        PositionType positionType,
        uint128 collateral,
        uint32 leverage,
        uint128 expectedPrice,
        uint64 maxSlippageRate, // %
        IPriceNode.Price price,
        address referrer,
        Callback.CallMeta meta
    ) internal {
        Market _market = markets[marketIdx];
        requestNonce += 1;

        PendingMarketOrder newRequest = PendingMarketOrder(
            user,
            marketIdx,
            positionType,
            collateral,
            expectedPrice,
            leverage,
            maxSlippageRate,
            _market.fees.openFeeRate,
            _market.fees.closeFeeRate,
            _market.fees.baseSpreadRate,
            liquidationParams.thresholdRate,
            _market.fees.borrowBaseRatePerHour,
            price,
            referrer,
            meta
        );

        pendingMarketRequests[requestNonce] = newRequest;
        address gravixAcc = getGravixAccountAddress(user);
        IGravixAccount(gravixAcc).process_requestMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            requestNonce,
            newRequest,
            gravixAccountCode.version
        );
    }

    function revert_requestMarketOrder(
        uint32 _reqNonce,
        PendingMarketOrder _pendRequest
    ) external override onlyGravixAccount(_pendRequest.user) reserve {
        delete pendingMarketRequests[_reqNonce];
        emit MarketOrderRequestRevert(_pendRequest.meta.callId, _pendRequest.user);
        if (_pendRequest.collateral > 0) {
            _transfer(
                usdt.wallet,
                _pendRequest.collateral,
                _pendRequest.user,
                _makeCell(_pendRequest.meta.nonce),
                _pendRequest.meta.sendGasTo,
                MsgFlag.ALL_NOT_RESERVED
            );
        } else {
            _sendCallbackOrGas(
                _pendRequest.user,
                _pendRequest.meta.nonce,
                false, _pendRequest.meta.sendGasTo
            );
        }
    }

    function finish_requestMarketOrder(
        uint32 reqNonce,
        PendingMarketOrder request,
        uint32 positionKey
    ) external override onlyGravixAccount(request.user) reserve {
        delete pendingMarketRequests[reqNonce];
        collateralReserve += request.collateral;

        emit MarketOrder(
            request.meta.callId,
            request.user,
            request.marketIdx,
            request.positionType,
            request.collateral,
            request.expectedPrice,
            request.leverage,
            request.maxSlippageRate,
            positionKey
        );

        OracleType priceSource = markets[request.marketIdx].priceSource;
        OracleConfig oracleConf = oracleConfigs[request.marketIdx];

        // if market uses offchain oracle and we have valid price, we can execute order right now
        if (priceSource == OracleType.PriceNode && checkPrice(request.price, oracleConf.priceNode)) {
            _executeOrder(
                request.user,
                positionKey,
                request.marketIdx,
                request.collateral,
                request.leverage,
                request.positionType,
                request.price.price,
                request.meta
            );
            return;
        }

        _sendOpenOrderOracleRequest(
            request.user,
            positionKey,
            request.marketIdx,
            request.collateral,
            request.leverage,
            request.positionType,
            request.meta
        );
    }

    function _handleLimitOrder(
        address _user,
        uint128 collateral,
        TvmCell orderParamsPayload,
        Callback.CallMeta meta
    ) internal returns (bool) {
        (
            uint32 marketIdx,
            PositionType positionType,
            uint32 leverage,
            uint128 targetPrice,
            LimitOrderType limitOrderType,
            IPriceNode.Price price,
            address referrer
        ) = decodeLimitOrder(orderParamsPayload);

        if (!validateOrderParams(marketIdx, collateral, leverage, 0)) return false;
        // TODO check position allowed
        if (!marketOpen(marketIdx)) return false;

        _limitOrder(
            _user,
            marketIdx,
            positionType,
            collateral,
            leverage,
            targetPrice,
            limitOrderType,
            price,
            referrer,
            meta
        );
        return true;
    }

    function _limitOrder(
        address _user,
        uint32 _marketIdx,
        PositionType _positionType,
        uint128 _collateral,
        uint32 _leverage,
        uint128 _targetPrice,
        LimitOrderType _limitOrderType,
        IPriceNode.Price _price,
        address _referrer,
        Callback.CallMeta _meta
    ) internal {

        _sendOpenOrderOracleLimitRequest(
            _user,
            requestNonce,
            _marketIdx,
            _collateral,
            _leverage,
            _positionType,
            _limitOrderType,
            _referrer,
            _targetPrice,
            _price,
            _meta
        );
    }

    function oracle_requestLimitOrder(
        uint64 _nonce,
        address _user,
        uint32 _marketIdx,
        PositionType _positionType,
        uint128 _collateral,
        uint32 _leverage,
        uint128 _targetPrice,
        LimitOrderType _limitOrderType,
        IPriceNode.Price _price,
        address _referrer,
        Callback.CallMeta _meta,
        uint128 _assetPrice
    ) external override onlyOracleProxy(_nonce) reserve {
        Market _market = markets[_marketIdx];
        requestNonce += 1;
        uint128 positionSizeAsset = calculatePositionAssetSize(_collateral, _leverage, _assetPrice);
        PendingLimitOrder newRequest = PendingLimitOrder(
            _user,
            _marketIdx,
            _positionType,
            _collateral,
            _targetPrice,
            _limitOrderType,
            _leverage,
            _market.fees.openFeeRate,
            _market.fees.closeFeeRate,
            _market.fees.baseSpreadRate,
            liquidationParams.thresholdRate,
            _market.fees.borrowBaseRatePerHour,
            _price,
            _referrer,
            _assetPrice,
            positionSizeAsset,
            _meta
        );
        pendingLimitRequests[requestNonce] = newRequest;


        _requestLimitOrder(newRequest, requestNonce);
    }

    function revert_requestLimitOrder(
        uint32 _reqNonce,
        PendingLimitOrder _pendRequest
    ) external override onlyGravixAccount(_pendRequest.user) reserve {
        delete pendingLimitRequests[_reqNonce];
        emit LimitOrderRequestRevert(_pendRequest.meta.callId, _pendRequest.user);
        if (_pendRequest.collateral > 0) {
            _transfer(
                usdt.wallet,
                _pendRequest.collateral,
                _pendRequest.user,
                _makeCell(_pendRequest.meta.nonce),
                _pendRequest.meta.sendGasTo,
                MsgFlag.ALL_NOT_RESERVED
            );
        } else {
            _sendCallbackOrGas(
                _pendRequest.user,
                _pendRequest.meta.nonce,
                false, _pendRequest.meta.sendGasTo
            );
        }
    }

    function finish_requestLimitOrder(
        uint32 reqNonce,
        PendingLimitOrder request,
        uint32 positionKey
    ) external override onlyGravixAccount(request.user) reserve {
        delete pendingLimitRequests[reqNonce];
        collateralReserve += request.collateral;

        emit LimitOrder(
            request.meta.callId,
            request.user,
            request.marketIdx,
            request.positionType,
            request.orderType,
            request.collateral,
            request.targetPrice,
            request.leverage,
            positionKey
        );

    }

    // ----------------------------------------------------------------------------------
    // --------------------------- ORACLE REQUEST ---------------------------------------
    // ----------------------------------------------------------------------------------
    function _sendOpenOrderOracleRequest(
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 collateral,
        uint32 leverage,
        PositionType positionType,
        Callback.CallMeta meta
    ) internal view {
        address proxy = _deployOracleProxy(marketIdx, meta);
        IOracleProxy(proxy).setExecuteCallback{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            user, positionKey, collateral, leverage, positionType
        );
    }

    function _sendOpenOrderOracleLimitRequest(
        address _user,
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _collateral,
        uint32 _leverage,
        PositionType _positionType,
        LimitOrderType _limitOrderType,
        address _referer,
        uint128 _targetPrice,
        IPriceNode.Price _userPrice,
        Callback.CallMeta _meta
    ) internal view {
        address proxy = _deployOracleProxy(_marketIdx, _meta);
        IOracleProxy(proxy).setRequestLimitCallback{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _user,
            _positionKey,
            _collateral,
            _leverage,
            _positionType,
            _limitOrderType,
            _referer,
            _targetPrice,
            _userPrice
        );
    }

    function _sendCloseOrderOracleRequest(
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        Callback.CallMeta meta
    ) internal view {
        address proxy = _deployOracleProxy(marketIdx, meta);
        IOracleProxy(proxy).setCloseCallback{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(user, positionKey);
    }

    function _sendLiquidationOracleRequest(
        address liquidator,
        uint32 marketIdx,
        PositionIdx[] positions,
        Callback.CallMeta meta
    ) internal view {
        address proxy = _deployOracleProxy(marketIdx, meta);
        uint128 callbackValue = uint128(positions.length) * Gas.LIQUIDATION_VALUE;
        IOracleProxy(proxy).setLiquidationCallback{value: callbackValue, flag: MsgFlag.SENDER_PAYS_FEES}(liquidator, positions);
    }

    function _deployOracleProxy(
        uint32 marketIdx, Callback.CallMeta meta
    ) internal view returns (address) {
        OracleType priceSource = markets[marketIdx].priceSource;
        OracleConfig oracleConf = oracleConfigs[marketIdx];

        emit OraclePriceRequested(meta.callId, marketIdx);
        // update random seed
        rnd.shuffle();
        return new OracleProxy{
            stateInit: _buildOracleProxyInitData(rnd.next(uint64(2**64 - 1))),
            value: Gas.ORACLE_PROXY_DEPLOY
        }(
            usdt.root, priceNode, marketIdx, priceSource, oracleConf, meta
        );
    }

    // --------------------------- REFERRAL LOGIC ---------------------------------------
    function withdrawReferralBalance(Callback.CallMeta meta) external view onlyActive reserve {
        require (msg.value >= Gas.MIN_MSG_VALUE, Errors.LOW_MSG_VALUE);

        address acc = getGravixAccountAddress(msg.sender);
        IGravixAccount(acc).process_withdrawReferralBalance{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(meta);
    }

    function finish_withdrawReferralBalance(
        address user, uint128 refBal, Callback.CallMeta meta
    ) external view override onlyGravixAccount(user) reserve {
        if (refBal > 0) {
            emit ReferralBalanceWithdraw(meta.callId, user, refBal);
            _transfer(
                usdt.wallet, refBal, user, _makeCell(meta.nonce), meta.sendGasTo, MsgFlag.ALL_NOT_RESERVED
            );
        } else {
            _sendCallbackOrGas(user, meta.nonce, false, meta.sendGasTo);
        }
    }

    function _sendReferrerFee(address referrer, address referral, uint128 fee, Callback.CallMeta meta) internal view {
        address referrerAcc = getGravixAccountAddress(referrer);

        emit ReferralPayment(
            meta.callId,
            referrer,
            referral,
            fee
        );
        IGravixAccount(referrerAcc).process_sendReferrerFee{value: Gas.SEND_REF_FEE_VALUE, flag: MsgFlag.SENDER_PAYS_FEES}(
            fee, meta
        );
    }

    function _distributeReferralFee(
        uint128 fee,
        address referrer,
        address grandReferrer,
        address referral,
        ReferralFeeSchema feeSchema,
        Callback.CallMeta meta
    ) internal view returns (uint128 remainingFee) {
        remainingFee = fee;
        if (referrer != address(0)) {
            uint128 referrerFee = math.muldiv(fee, referralFeeSchema[uint8(feeSchema)], Constants.HUNDRED_PERCENT);
            remainingFee -= referrerFee;
            if (referrerFee > 0) {
                _sendReferrerFee(referrer, referral, referrerFee, meta);
            }
        }
        if (grandReferrer != address(0)) {
            uint128 grandReferrerFee = math.muldiv(fee, grandReferralFeeSchema[uint8(feeSchema)], Constants.HUNDRED_PERCENT);
            remainingFee -= grandReferrerFee;
            if (grandReferrerFee > 0) {
                _sendReferrerFee(grandReferrer, referral, grandReferrerFee, meta);
            }
        }
    }

    function _collectOpenFeeAndReferral(
        uint128 openFee, address referrer, address grandReferrer, address referral, Callback.CallMeta meta
    ) internal {
        openFee = _distributeReferralFee(openFee, referrer, grandReferrer, referral, ReferralFeeSchema.OpenFee, meta);
        _collectOpenFee(openFee);
    }

    function _collectCloseFeeAndReferral(
        uint128 closeFee, address referrer, address grandReferrer, address referral, Callback.CallMeta meta
    ) internal {
        closeFee = _distributeReferralFee(closeFee, referrer, grandReferrer, referral, ReferralFeeSchema.CloseFee, meta);
        _collectCloseFee(closeFee);
    }

    function _collectPnlAndReferral(
        uint128 pnl, address referrer, address grandReferrer, address referral, Callback.CallMeta meta
    ) internal {
        pnl = _distributeReferralFee(pnl, referrer, grandReferrer, referral, ReferralFeeSchema.PnlFee, meta);
        _increaseInsuranceFund(pnl);
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER EXECUTE HANDLERS -------------------------------
    // ----------------------------------------------------------------------------------
    // @param nonce - oracle static parameter, required for addr calculation
    // @param user - order maker
    // @param positionKey - unique(per user) position key
    // @param marketIdx - market id
    // @param collateral - position collateral, 6 decimals number
    // @param leverage - position leverage, 2 decimals number
    // @param positionType - 0 - long, 1 - short
    // @param assetPrice - current asset price for this market, 8 decimals number
    // @param meta - txn meta
    function oracle_executeMarketOrder(
        uint64 nonce,
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 collateral,
        uint32 leverage,
        PositionType positionType,
        uint128 assetPrice,
        Callback.CallMeta meta
    ) external override onlyOracleProxy(nonce) reserve {
        _executeOrder(
            user,
            positionKey,
            marketIdx,
            collateral,
            leverage,
            positionType,
            assetPrice,
            meta
        );
    }

    function _executeOrder(
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 collateral,
        uint32 leverage,
        PositionType positionType,
        uint128 assetPrice,
        Callback.CallMeta meta
    ) internal {
        // reserve should be
        uint128 positionSizeAsset = calculatePositionAssetSize(collateral, leverage, assetPrice);
        uint64 dynamicSpread = getDynamicSpread(positionSizeAsset, marketIdx, positionType);

        Funding _funding = _updateFunding(marketIdx, assetPrice);
        uint16 _error = _addPositionToMarketOrReturnErr(marketIdx, positionSizeAsset, assetPrice, positionType);

        address gravixAcc = getGravixAccountAddress(user);
        if (_error == 0) {
            int256 funding = positionType == PositionType.Long ? _funding.accLongUSDFundingPerShare : _funding.accShortUSDFundingPerShare;

            IGravixAccount(gravixAcc).process_executeMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                positionKey,
                marketIdx,
                positionSizeAsset,
                positionType,
                assetPrice,
                dynamicSpread,
                funding,
                meta,
                gravixAccountCode.version
            );
        } else {
            // order cant be executed now, some limits reached and etc.
            IGravixAccount(gravixAcc).process_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                positionKey,
                meta,
                gravixAccountCode.version
            );
        }
    }

    function revert_executeMarketOrder(
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 collateral,
        uint128 positionSizeAsset,
        uint128 assetPrice,
        PositionType positionType,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        emit MarketOrderExecutionRevert(meta.callId, user, positionKey);

        _removePositionFromMarket(marketIdx, positionSizeAsset, assetPrice, positionType);

        // too high slippage
        if (collateral > 0) {
            collateralReserve -= collateral;
            _transfer(
                usdt.wallet, collateral, user, _makeCell(meta.nonce), meta.sendGasTo, MsgFlag.ALL_NOT_RESERVED
            );
        } else {
            // tried to execute non-existent order
            _sendCallbackOrGas(user, meta.nonce, false, meta.sendGasTo);
        }
    }

    function finish_executeMarketOrder(
        address user,
        uint32 positionKey,
        IGravixAccount.Position newPos,
        address referrer,
        address grandReferrer,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserveAndSuccessCallback(meta) {
        _collectOpenFeeAndReferral(newPos.openFee, referrer, grandReferrer, user, meta);
        collateralReserve -= newPos.openFee;

        uint128 positionSizeAssetRaw = calculatePositionAssetSize(newPos.initialCollateral, newPos.leverage, newPos.markPrice);
        _removePositionFromMarket(newPos.marketIdx, positionSizeAssetRaw, newPos.markPrice, newPos.positionType);

        uint128 positionSizeAsset = calculatePositionAssetSize(newPos.initialCollateral - newPos.openFee, newPos.leverage, newPos.openPrice);
        _addPositionToMarket(newPos.marketIdx, positionSizeAsset, newPos.markPrice, newPos.positionType);

        emit MarketOrderExecution(
            meta.callId,
            user,
            newPos,
            positionKey
        );
    }
    function _requestLimitOrder(
        IGravixVault.PendingLimitOrder _pendingLimitOrder,
        uint32 _requestNonce
    ) internal {
        // reserve should be
        address gravixAcc = getGravixAccountAddress(_pendingLimitOrder.user);

        IGravixAccount(gravixAcc).process_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _requestNonce,
            _pendingLimitOrder,
            gravixAccountCode.version
        );
    }
    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param assetPrice - position price, 8 decimals number
    function calculatePositionAssetSize(uint128 collateral, uint32 leverage, uint128 assetPrice) public pure returns (uint128 positionSizeAsset) {
        return math.muldiv(math.muldiv(collateral, leverage, Constants.LEVERAGE_BASE), Constants.PRICE_DECIMALS, assetPrice);
    }

    function getDynamicSpread(
        uint128 positionSizeAsset,
        uint32 marketIdx,
        PositionType positionType
    ) public view responsible returns (uint64 dynamicSpread) {
        uint128 newNoi;

        Market market = markets[marketIdx];
        // calculate dynamic dynamicSpread multiplier
        if (positionType == PositionType.Long) {
            uint128 newLongsTotal = market.totalLongsAsset + positionSizeAsset / 2;
            newNoi = newLongsTotal - math.min(market.totalShortsAsset, newLongsTotal);
        } else {
            uint128 newShortsTotal = market.totalShortsAsset + positionSizeAsset / 2;
            newNoi = newShortsTotal - math.min(market.totalLongsAsset, newShortsTotal);
        }
        dynamicSpread = uint64(math.muldiv(newNoi, market.fees.baseDynamicSpreadRate, market.depthAsset));
        return { value: 0, bounce: false, flag: MsgFlag.REMAINING_GAS } dynamicSpread;
    }
    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER CANCEL HANDLERS --------------------------------
    // ----------------------------------------------------------------------------------
    function cancelMarketOrder(address user, uint32 positionKey, Callback.CallMeta meta) external view onlyActive reserve {
        require (msg.value >= Gas.MIN_MSG_VALUE, Errors.LOW_MSG_VALUE);

        address gravixAcc = getGravixAccountAddress(user);
        IGravixAccount(gravixAcc).process_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            positionKey,
            meta,
            gravixAccountCode.version
        );
    }

    function revert_cancelMarketOrder(
        address user, uint32 positionKey, Callback.CallMeta meta
    ) external view override onlyGravixAccount(user) reserveAndFailCallback(meta) {
        emit CancelMarketOrderRevert(meta.callId, user, positionKey);
    }

    function finish_cancelMarketOrder(
        address user, uint32 positionKey, uint128 collateral, Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        collateralReserve -= collateral;

        emit CancelMarketOrder(meta.callId, user, positionKey);
        _transfer(usdt.wallet, collateral, user, _makeCell(meta.nonce), meta.sendGasTo, MsgFlag.ALL_NOT_RESERVED);
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- ORDER CLOSE HANDLERS ---------------------------------
    // ----------------------------------------------------------------------------------
    function forceClosePositions(
        address[] users,
        uint32[] positionKeys,
        uint32[] marketIdx,
        IPriceNode.Price[] prices,
        Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        require (users.length == positionKeys.length, Errors.BAD_INPUT);
        require (users.length == marketIdx.length, Errors.BAD_INPUT);
        require (msg.value >= Gas.MIN_MSG_VALUE * users.length, Errors.LOW_MSG_VALUE);

        for (uint i = 0; i < users.length; i++) {
            OracleType priceSource = markets[marketIdx[i]].priceSource;
            OracleConfig oracleConf = oracleConfigs[marketIdx[i]];

            // if market uses offchain oracle and we have valid price, we can close order right now
            if (priceSource == OracleType.PriceNode && checkPrice(prices[i], oracleConf.priceNode)) {
                _closePosition(
                    users[i], positionKeys[i], marketIdx[i], prices[i].price, Gas.MIN_MSG_VALUE - 0.1 ever, meta
                );
                continue;
            }

            address proxy = _deployOracleProxy(marketIdx[i], meta);
            IOracleProxy(proxy).setCloseCallback{value: Gas.MIN_MSG_VALUE - Gas.ORACLE_PROXY_DEPLOY - 0.01 ever}(
                users[i], positionKeys[i]
            );
        }
    }

    // @notice Should be used by admin very carefully when oracle is dead by some reason to save users
    // Bad price here can cause bad contract state!
    function forceClosePositionsWithPrice(
        address[] users,
        uint32[] positionKeys,
        uint32[] marketIdx,
        uint128[] assetPrices,
        Callback.CallMeta meta
    ) external onlyOwner reserveAndSendGas(meta) {
        require (users.length == positionKeys.length, Errors.BAD_INPUT);
        require (positionKeys.length == marketIdx.length, Errors.BAD_INPUT);
        require (marketIdx.length == assetPrices.length, Errors.BAD_INPUT);
        require (msg.value >= Gas.MIN_MSG_VALUE * users.length, Errors.LOW_MSG_VALUE);

        for (uint i = 0; i < users.length; i++) {
            _closePosition(
                users[i], positionKeys[i], marketIdx[i], assetPrices[i], Gas.MIN_MSG_VALUE - 0.1 ever, meta
            );
        }
    }

    function closePosition(
        uint32 positionKey,
        uint32 marketIdx,
        IPriceNode.Price price,
        Callback.CallMeta meta
    ) external onlyActive reserve {
        require (msg.value >= Gas.MIN_MSG_VALUE, Errors.LOW_MSG_VALUE);

        // soft fail
        // optimistic check on market, we will check that position matches it in account
        if (!marketOpen(marketIdx)) {
            emit ClosePositionRevert(meta.callId, msg.sender, positionKey, marketIdx);
            _sendCallbackOrGas(msg.sender, meta.nonce, false, meta.sendGasTo);
            return;
        }

        OracleType priceSource = markets[marketIdx].priceSource;
        OracleConfig oracleConf = oracleConfigs[marketIdx];

        // if market uses offchain oracle and we have valid price, we can close order right now
        if (priceSource == OracleType.PriceNode && checkPrice(price, oracleConf.priceNode)) {
            _closePosition(msg.sender, positionKey, marketIdx, price.price, 0, meta);
            return;
        }

        _sendCloseOrderOracleRequest(msg.sender, positionKey, marketIdx, meta);
    }

    // @param nonce - oracle static parameter, required for addr calculation
    // @param user - order maker
    // @param positionKey - unique(per user) position key
    // @param marketIdx - market id
    // @param assetPrice - current asset price for this market, 8 decimals number
    // @param meta - txn meta
    function oracle_closePosition(
        uint64 nonce,
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 assetPrice,
        Callback.CallMeta meta
    ) external override onlyOracleProxy(nonce) reserve {
        _closePosition(user, positionKey, marketIdx, assetPrice, 0, meta);
    }

    function _closePosition(
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 assetPrice,
        uint128 value,
        Callback.CallMeta meta
    ) internal {
        uint16 flag = value == 0 ? MsgFlag.ALL_NOT_RESERVED : 0;
        Funding _funding = _updateFunding(marketIdx, assetPrice);
        address gravixAcc = getGravixAccountAddress(user);
        IGravixAccount(gravixAcc).process_closePosition{value: value, flag: flag}(
            positionKey,
            marketIdx,
            assetPrice,
            _funding,
            meta,
            gravixAccountCode.version
        );
    }

    function revert_closePosition(
        address user, uint32 positionKey, uint32 marketIdx, Callback.CallMeta meta
    ) external view override onlyGravixAccount(user) reserveAndFailCallback(meta) {
        emit ClosePositionRevert(meta.callId, user, positionKey, marketIdx);
    }

    function finish_closePosition(
        address user,
        uint32 positionKey,
        uint128 assetPrice,
        IGravixAccount.PositionView positionView,
        address referrer,
        address grandReferrer,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        // we already deducted open fee when position was opened
        uint128 collateral = positionView.position.initialCollateral - positionView.position.openFee;
        collateralReserve -= collateral;

        uint128 initialPositionSizeAsset = calculatePositionAssetSize(collateral, positionView.position.leverage, positionView.position.openPrice);
        _removePositionFromMarket(
            positionView.position.marketIdx,
            initialPositionSizeAsset,
            assetPrice,
            positionView.position.positionType
        );

        if (positionView.liquidate) {
            // increase insurance fund + send referrer payment
            _collectPnlAndReferral(collateral, referrer, grandReferrer, user, meta);

            emit LiquidatePosition(meta.callId, user, user, positionKey, positionView);
            _sendCallbackOrGas(user, meta.nonce, true, meta.sendGasTo);
        } else {
            int256 pnlLimit = math.muldiv(collateral, maxPnlRate, Constants.HUNDRED_PERCENT);
            int256 limitedPnl = math.min(positionView.pnl, pnlLimit);

            int256 pnlWithFees = limitedPnl - positionView.borrowFee - positionView.fundingFee;
            _collectCloseFeeAndReferral(positionView.closeFee, referrer, grandReferrer, user, meta);

            uint128 debt;
            if (pnlWithFees < 0) {
                // increase insurance fund + send referrer payment
                _collectPnlAndReferral(uint128(math.abs(pnlWithFees)), referrer, grandReferrer, user, meta);
            }
            if (pnlWithFees > 0) {
                // positive debt if we dont have enough money to pay pnl
                debt = _decreaseInsuranceFund(uint128(pnlWithFees));
            }

            emit ClosePosition(meta.callId, user, positionKey, positionView);
            // we know for sure collateral > pnl and fee, otherwise position would have been liquidated
            uint128 userNetUsdt = uint128(collateral + pnlWithFees - debt - positionView.closeFee);
            _transfer(usdt.wallet, userNetUsdt, user, _makeCell(meta.nonce), meta.sendGasTo, MsgFlag.ALL_NOT_RESERVED);
            if (debt > 0) {
                emit Debt(meta.callId, user, debt);
            }
        }
    }

    function _handleAddCollateral(
        address user, uint128 amount, TvmCell actionPayload, Callback.CallMeta meta
    ) internal view returns (bool success) {
        (uint32 marketIdx, uint32 positionKey) = decodeAddCollateral(actionPayload);
        // optimistic check on market, we will check that position matches it in account
        if (!marketOpen(marketIdx)) return false;
        _addCollateral(amount, user, marketIdx, positionKey, meta);
        return true;
    }

    function _addCollateral(
        uint128 amount,
        address user,
        uint32 marketIdx,
        uint32 positionKey,
        Callback.CallMeta meta
    ) internal view {
        address gravixAcc = getGravixAccountAddress(user);
        IGravixAccount(gravixAcc).process_addCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            amount,
            marketIdx,
            positionKey,
            meta,
            gravixAccountCode.version
        );
    }

    function revert_addCollateral(
        address user, uint128 amount, uint32 marketIdx, uint32 positionKey, Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        emit AddPositionCollateralRevert(meta.callId, user, marketIdx, positionKey, amount);

        _transfer(
            usdt.wallet, amount, user, _makeCell(meta.nonce), meta.sendGasTo, MsgFlag.ALL_NOT_RESERVED
        );
    }

    function finish_addCollateral(
        address user,
        uint128 amount,
        IGravixAccount.Position position,
        uint32 oldLeverage,
        uint32 positionKey,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserveAndSuccessCallback(meta) {
        collateralReserve += amount;

        uint128 newCollateral = position.initialCollateral - position.openFee;
        uint128 oldCollateral = newCollateral - amount;

        uint128 oldPosSize = calculatePositionAssetSize(oldCollateral, oldLeverage, position.markPrice);
        uint128 newPosSize = calculatePositionAssetSize(newCollateral, position.leverage, position.markPrice);

        // position size doesnt change when we change collateral, but because of rounding err we can get tiny delta
        // we dont want it to accumulate because it could affect further calculations
        if (oldPosSize != newPosSize) {
            Market _market = markets[position.marketIdx];

            _removePositionFromMarket(
                position.marketIdx,
                oldPosSize,
                _market.lastNoiUpdatePrice,
                position.positionType
            );

            _addPositionToMarket(
                position.marketIdx,
                newPosSize,
                _market.lastNoiUpdatePrice,
                position.positionType
            );
        }

        emit AddPositionCollateral(meta.callId, user, positionKey, amount, position);
    }

    function removeCollateral(
        uint128 amount, uint32 positionKey, uint32 marketIdx, Callback.CallMeta meta
    ) external view onlyActive reserve {
        require (msg.value >= Gas.MIN_MSG_VALUE, Errors.LOW_MSG_VALUE);

        // optimistic check on market, we will check that position matches it in account
        // soft fail because market state is dynamic
        if (!marketOpen(marketIdx)) {
            emit RemovePositionCollateralRevert(meta.callId, msg.sender, positionKey, marketIdx, amount);
            _sendCallbackOrGas(msg.sender, meta.nonce, false, meta.sendGasTo);
            return;
        }

        address gravixAcc = getGravixAccountAddress(msg.sender);
        IGravixAccount(gravixAcc).process_removeCollateral{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            amount,
            positionKey,
            marketIdx,
            markets[marketIdx].maxLeverage,
            minPositionCollateral,
            meta,
            gravixAccountCode.version
        );
    }

    function revert_removeCollateral(
        address user, uint128 amount, uint32 positionKey, uint32 marketIdx, Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserveAndFailCallback(meta) {
        emit RemovePositionCollateralRevert(meta.callId, user, positionKey, marketIdx, amount);
    }

    function finish_removeCollateral(
        address user,
        uint128 amount,
        IGravixAccount.Position position,
        uint32 oldLeverage,
        uint32 positionKey,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        collateralReserve -= amount;

        uint128 newCollateral = position.initialCollateral - position.openFee;
        uint128 oldCollateral = newCollateral + amount;

        uint128 oldPosSize = calculatePositionAssetSize(oldCollateral, oldLeverage, position.markPrice);
        uint128 newPosSize = calculatePositionAssetSize(newCollateral, position.leverage, position.markPrice);

        // position size doesnt change when we change collateral, but because of rounding err we can get tiny delta
        // we dont want it to accumulate because it could affect further calculations
        if (oldPosSize != newPosSize) {
            Market _market = markets[position.marketIdx];

            _removePositionFromMarket(
                position.marketIdx,
                oldPosSize,
                _market.lastNoiUpdatePrice,
                position.positionType
            );

            _addPositionToMarket(
                position.marketIdx,
                newPosSize,
                _market.lastNoiUpdatePrice,
                position.positionType
            );
        }

        emit RemovePositionCollateral(meta.callId, user, positionKey, amount, position);
        _transfer(usdt.wallet, amount , user, _makeCell(meta.nonce), meta.sendGasTo, MsgFlag.ALL_NOT_RESERVED);
    }


    // ----------------------------------------------------------------------------------
    // --------------------------- LIQUIDATION ------------------------------------------
    // ----------------------------------------------------------------------------------
    // @notice 3 ever for every market + 1.05 ever for every position
    // @dev Aggregate by market to minimize requests to oracle
    function liquidatePositions(
        mapping (uint32 => LiquidationData) liquidations, Callback.CallMeta meta
    ) external view onlyActive reserveAndSendGas(meta) {
        // dont spend gas to check msg.value, it will fail with 37 code anyway if user didnt send enough, because we use exact values here
        for ((uint32 marketIdx, LiquidationData liqData) : liquidations) {

            OracleType priceSource = markets[marketIdx].priceSource;
            OracleConfig oracleConf = oracleConfigs[marketIdx];

            // if market uses offchain oracle and we have valid price, we can liquidate positions right now
            if (priceSource == OracleType.PriceNode && checkPrice(liqData.price, oracleConf.priceNode)) {
                uint128 value = uint128(liqData.positions.length * Gas.LIQUIDATION_VALUE) + Gas.ORACLE_PROXY_DEPLOY;
                this.self_liquidatePositions{value: value}(
                    msg.sender,
                    marketIdx,
                    liqData.positions,
                    liqData.price.price,
                    meta,
                    0
                );
                continue;
            }

            _sendLiquidationOracleRequest(msg.sender, marketIdx, liqData.positions, meta);
        }
    }

    function revert_liquidatePositions(
        address user, address liquidator, uint32 positionKey, uint32 marketIdx, Callback.CallMeta meta
    ) external view override onlyGravixAccount(user) reserveAndFailCallback(meta) {
        emit LiquidatePositionRevert(meta.callId, liquidator, user, positionKey, marketIdx);
    }

    function oracle_liquidatePositions(
        uint64 nonce, address liquidator, uint32 marketIdx, PositionIdx[] positions, uint128 assetPrice, Callback.CallMeta meta
    ) external override onlyOracleProxy(nonce) reserve {
        this.self_liquidatePositions{
                value: 0,
                flag: MsgFlag.ALL_NOT_RESERVED,
                bounce: false
        }(
            liquidator,
            marketIdx,
            positions,
            assetPrice,
            meta,
            0
        );
    }


    function self_liquidatePositions(
        address liquidator,
        uint32 marketIdx,
        PositionIdx[] positions,
        uint128 assetPrice,
        Callback.CallMeta meta,
        uint256 _startIdx
    ) external reserve {
        require (msg.sender == address(this), Errors.BAD_SENDER);

        Funding _funding = _updateFunding(marketIdx, assetPrice);
        for (uint i = _startIdx; i < positions.length && i < _startIdx + Constants.LIQUIDATION_BATCH_SIZE; i++) {
            PositionIdx position = positions[i];
            address gravixAcc = getGravixAccountAddress(position.user);
            // reserve 0.06 ever here to cover computation costs of iterating, needed for big arrays
            IGravixAccount(gravixAcc).process_liquidatePositions{value: Gas.LIQUIDATION_VALUE - 0.06 ever}(
                liquidator,
                position.positionKey,
                marketIdx,
                assetPrice,
                _funding,
                meta,
                gravixAccountCode.version
            );
        }

        if (_startIdx + Constants.LIQUIDATION_BATCH_SIZE < positions.length) {
            this.self_liquidatePositions{
                    value: 0,
                    flag: MsgFlag.ALL_NOT_RESERVED,
                    bounce: false
            }(
                liquidator,
                marketIdx,
                positions,
                assetPrice,
                meta,
                _startIdx + Constants.LIQUIDATION_BATCH_SIZE
            );
        } else {
            meta.sendGasTo.transfer(0, false, MsgFlag.ALL_NOT_RESERVED);
        }
    }

    function finish_liquidatePositions(
        address user,
        address liquidator,
        uint32 positionKey,
        uint128 assetPrice,
        IGravixAccount.PositionView positionView,
        address referrer,
        address grandReferrer,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserve {
        // we already deducted open fee when position was opened
        uint128 collateral = positionView.position.initialCollateral - positionView.position.openFee;
        collateralReserve -= collateral;

        // we added exactly this amount when opened order
        uint128 initialPositionSizeAsset = calculatePositionAssetSize(collateral, positionView.position.leverage, positionView.position.openPrice);
        _removePositionFromMarket(
            positionView.position.marketIdx,
            initialPositionSizeAsset,
            assetPrice,
            positionView.position.positionType
        );

        uint128 liquidatorReward = math.muldiv(collateral, liquidationParams.rewardShare, Constants.HUNDRED_PERCENT);

        _collectPnlAndReferral(collateral - liquidatorReward, referrer, grandReferrer, user, meta);

        emit LiquidatePosition(meta.callId, user, liquidator, positionKey, positionView);

        _transfer(usdt.wallet, liquidatorReward, liquidator, _makeCell(meta.nonce), meta.sendGasTo, MsgFlag.SENDER_PAYS_FEES);
        _sendCallbackOrGas(user, meta.nonce, true, meta.sendGasTo);
    }

    // ----------------------------------------------------------------------------------
    // --------------------------- POSITION LIMITS --------------------------------------
    // ----------------------------------------------------------------------------------
    // @param marketIdx - market id
    // @param collateral - order collateral, 6 decimals number
    // @param leverage - order leverage, 2 decimals number
    // @param assetPrice - position price, 8 decimals number
    // @param positionType - 0 - long, 1 - short
    function checkPositionAllowed(
        uint32 marketIdx,
        uint128 collateral,
        uint32 leverage,
        uint128 assetPrice,
        PositionType positionType
    ) public view returns (uint16) {
        uint128 positionSizeAsset = calculatePositionAssetSize(collateral, leverage, assetPrice);
        (,,uint16 _error) = _calculatePositionImpactAndCheckAllowed(marketIdx, positionSizeAsset, assetPrice, positionType);
        return _error;
    }

    function _marketNOI(Market _market) internal pure returns (uint128) {
        return _market.totalLongsAsset > _market.totalShortsAsset ?
            _market.totalLongsAsset - _market.totalShortsAsset :
            _market.totalShortsAsset - _market.totalLongsAsset;
    }

    // @dev Will not apply changes if _error > 0
    // @param marketIdx - market id
    // @param positionSizeAsset - position value in asset, 6 decimals number
    // @param curAssetPrice - position price, 8 decimals number
    // @param positionType - 0 - long, 1 - short
    function _addPositionToMarketOrReturnErr(
        uint32 marketIdx, uint128 positionSizeAsset, uint128 curAssetPrice, PositionType positionType
    ) internal returns (uint16) {
        (
            Market _market,
            uint128 _totalNOI,
            uint16 _error
        ) = _calculatePositionImpactAndCheckAllowed(marketIdx, positionSizeAsset, curAssetPrice, positionType);
        if (_error == 0) {
            markets[marketIdx] = _market;
            totalNOI = _totalNOI;
        }
        return _error;
    }

    // @param marketIdx - market id
    // @param positionSizeAsset - position value in asset, 6 decimals number
    // @param curAssetPrice - position price, 8 decimals number
    // @param positionType - 0 - long, 1 - short
    function _calculatePositionImpactAndCheckAllowed(
        uint32 marketIdx,
        uint128 positionSizeAsset,
        uint128 curAssetPrice,
        PositionType positionType
    ) internal view returns (Market _market, uint128 _totalNOI, uint16 _error) {
        (_market, _totalNOI) = _calculatePositionImpact(marketIdx, positionSizeAsset, curAssetPrice, positionType, false);

        uint128 shortsUsd = math.muldiv(_market.totalShortsAsset, curAssetPrice, Constants.PRICE_DECIMALS);
        uint128 longsUsd = math.muldiv(_market.totalLongsAsset, curAssetPrice, Constants.PRICE_DECIMALS);
        // market limits
        if (shortsUsd > _market.maxTotalShortsUSD || longsUsd > _market.maxTotalLongsUSD) _error = Errors.MARKET_POSITIONS_LIMIT_REACHED;
        // common platform limit
        if (totalNOILimitEnabled && math.muldiv(
            poolAssets.balance,
            maxPoolUtilRatio,
            Constants.HUNDRED_PERCENT
        ) < _totalNOI) _error = Errors.PLATFORM_POSITIONS_LIMIT_REACHED;
        return (_market, _totalNOI, _error);
    }

    // @param marketIdx - market id
    // @param positionSizeAsset - position value in asset, 6 decimals number
    // @param curAssetPrice - asset price on moment of update, required for TNOI calculation, 8 decimals number
    // @param positionType - 0 - long, 1 - short
    // @param bool - whether position is removed or added
    function _calculatePositionImpact(
        uint32 marketIdx, uint128 positionSizeAsset, uint128 curAssetPrice, PositionType positionType, bool remove
    ) internal view returns (Market _market, uint128 _totalNOI) {
        _market = markets[marketIdx];
        _totalNOI = totalNOI;

        uint128 noiAssetBefore = _marketNOI(_market);
        uint128 noiUsdBefore = math.muldiv(noiAssetBefore, _market.lastNoiUpdatePrice, Constants.PRICE_DECIMALS);

        if (positionType == PositionType.Long) {
            _market.totalLongsAsset = remove ? (_market.totalLongsAsset - positionSizeAsset) : (_market.totalLongsAsset + positionSizeAsset);
        } else {
            _market.totalShortsAsset = remove ? (_market.totalShortsAsset - positionSizeAsset) : (_market.totalShortsAsset + positionSizeAsset);
        }

        uint128 noiAssetAfter = _marketNOI(_market);
        uint128 noiUsdAfter = math.muldiv(noiAssetAfter, curAssetPrice, Constants.PRICE_DECIMALS);

        _totalNOI -= math.muldiv(noiUsdBefore, _market.noiWeight, Constants.WEIGHT_BASE);
        _totalNOI += math.muldiv(noiUsdAfter, _market.noiWeight, Constants.WEIGHT_BASE);

        _market.lastNoiUpdatePrice = curAssetPrice;
    }


    // @param curAssetPrice - asset price on moment of update, required for TNOI calculation, 8 decimals number
    function _addPositionToMarket(
        uint32 marketIdx,
        uint128 positionSizeAsset,
        uint128 curAssetPrice,
        PositionType positionType
    ) internal {
        (
            markets[marketIdx],
            totalNOI
        ) = _calculatePositionImpact(marketIdx, positionSizeAsset, curAssetPrice, positionType, false);
    }

    // @param curAssetPrice - asset price on moment of update, required for TNOI calculation, 8 decimals number
    function _removePositionFromMarket(
        uint32 marketIdx,
        uint128 positionSizeAsset,
        uint128 curAssetPrice,
        PositionType positionType
    ) internal {
        (
            markets[marketIdx],
            totalNOI
        ) = _calculatePositionImpact(marketIdx, positionSizeAsset, curAssetPrice, positionType, true);
    }
    // ----------------------------------------------------------------------------------
    // --------------------------- FUNDING ----------------------------------------------
    // ----------------------------------------------------------------------------------
    // @param marketIdx - market id
    // @param assetPrice - asset price, 8 decimals number
    function _updateFunding(uint32 marketIdx, uint128 assetPrice) internal returns (Funding funding) {
        Market _market = markets[marketIdx];
        if (_market.lastFundingUpdateTime == 0) _market.lastFundingUpdateTime = now;

        _market.funding = _getUpdatedFunding(_market, assetPrice);
        _market.lastFundingUpdateTime = now;

        markets[marketIdx] = _market;
        return _market.funding;
    }

    // TODO: function for updating funding without real deal

    function getUpdatedFunding(
        mapping (uint32 => uint128) prices
    ) external view returns (mapping (uint32 => Funding) funding) {
        for ((uint32 marketIdx, uint128 assetPrice): prices) {
            funding[marketIdx] = _getUpdatedFunding(markets[marketIdx], assetPrice);
        }
        return funding;
    }

    function _getUpdatedFunding(Market _market, uint128 assetPrice) internal pure returns (Funding _funding) {
        if (_market.lastFundingUpdateTime == 0) _market.lastFundingUpdateTime = now;
        (int128 longRatePerHour, int128 shortRatePerHour) = _getFundingRates(_market);

        _funding.accLongUSDFundingPerShare = _market.funding.accLongUSDFundingPerShare + _calculateFunding(
            longRatePerHour,
            _market.totalLongsAsset,
            assetPrice,
            _market.lastFundingUpdateTime
        );

        _funding.accShortUSDFundingPerShare = _market.funding.accShortUSDFundingPerShare + _calculateFunding(
            shortRatePerHour,
            _market.totalShortsAsset,
            assetPrice,
            _market.lastFundingUpdateTime
        );

        return _funding;
    }

    // @param assetPrice - asset price, 8 decimals number
    function _calculateFunding(
        int256 ratePerHour,
        uint128 totalPosition,
        uint128 assetPrice,
        uint32 lastUpdateTime
    ) internal pure returns (int256) {
        if (ratePerHour == 0 || totalPosition == 0) return 0;
        // multiply by SCALING FACTOR in the beginning to prevent precision loss
        int256 fundingAsset = math.muldiv(ratePerHour * Constants.SCALING_FACTOR, totalPosition, Constants.HUNDRED_PERCENT);
        fundingAsset = math.muldiv(fundingAsset, (now - lastUpdateTime), Constants.HOUR);
        int256 fundingUsd = math.muldiv(fundingAsset, assetPrice, Constants.PRICE_DECIMALS);
        return fundingUsd / totalPosition;
    }

    // @notice returned rates are multiplied by 10**12, e.g 100% = 1_000_000_000_000
    function getFundingRates(uint32 marketIdx) public view returns (int128 longRatePerHour, int128 shortRatePerHour) {
        return _getFundingRates(markets[marketIdx]);
    }

    // @notice If rate is positive - trader should pay, negative - receive payment
    function _getFundingRates(Market _market) internal pure returns (int128 longRatePerHour, int128 shortRatePerHour) {
        uint128 noi = uint128(math.abs(int256(_market.totalLongsAsset) - _market.totalShortsAsset));
        uint128 fundingRatePerHour = math.muldiv(
            _market.fees.fundingBaseRatePerHour,
            math.muldiv(noi, Constants.SCALING_FACTOR, _market.depthAsset),
            Constants.SCALING_FACTOR
        );

        if (_market.totalLongsAsset >= _market.totalShortsAsset) {
            longRatePerHour = int128(fundingRatePerHour);
            if (_market.totalShortsAsset > 0) {
                shortRatePerHour = -1 * int128(
                    math.muldiv(fundingRatePerHour, _market.totalLongsAsset, _market.totalShortsAsset)
                );
            }
        } else {
            shortRatePerHour = int128(fundingRatePerHour);
            if (_market.totalLongsAsset > 0) {
                longRatePerHour = -1 * int128(math.muldiv(fundingRatePerHour, _market.totalShortsAsset, _market.totalLongsAsset));
            }
        }
        return (longRatePerHour, shortRatePerHour);
    }
}
