pragma ever-solidity ^0.62.0;


import "broxus-token-contracts/contracts/interfaces/ITokenRootUpgradeable.tsol";
import "broxus-token-contracts/contracts/interfaces/ITokenWalletUpgradeable.tsol";
import "broxus-token-contracts/contracts/interfaces/IAcceptTokensTransferCallback.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";
import "../../libraries/Gas.tsol";
import "../../libraries/Callback.tsol";
import "../../libraries/Errors.tsol";
import "../../libraries/Callback.tsol";
import "./GravixVaultHelpers.tsol";
import {RPlatform as Platform} from "../../Platform.tsol";


abstract contract GravixVaultUpgradable is GravixVaultHelpers {
    function updateGravixAccountCode(TvmCell code, Callback.CallMeta meta) external onlyOwner reserveAndSuccessCallback(meta) {
        GravixAccountCode = code;
        GravixAccountVersion += 1;
        emit GravixAccountCodeUpdate(meta.call_id, GravixAccountVersion - 1, GravixAccountVersion);
    }

    function updateOracleProxyCode(TvmCell code, Callback.CallMeta meta) external onlyOwner reserveAndSuccessCallback(meta) {
        oracleProxyCode = code;
        oracleProxyVersion += 1;
        emit OracleProxyCodeUpdate(meta.call_id, oracleProxyVersion - 1, oracleProxyVersion);
    }

    function upgradeGravixAccount(Callback.CallMeta meta) external view reserve {
        require (msg.value >= Gas.GRAVIX_ACC_UPGRADE_VALUE, Errors.LOW_MSG_VALUE);

        _upgradeGravixAccount(msg.sender, 0, meta);
    }

    // admin hook, no need for call_id or nonce
    function forceUpgradeGravixAccounts(address[] users, Callback.CallMeta meta) external view onlyOwner reserve {
        require (msg.value >= Gas.GRAVIX_ACC_UPGRADE_VALUE * (users.length + 1), Errors.LOW_MSG_VALUE);

        for (uint i = 0; i < users.length; i++) {
            _upgradeGravixAccount(users[i], Gas.GRAVIX_ACC_UPGRADE_VALUE, meta);
        }
    }

    function _upgradeGravixAccount(address user, uint128 value, Callback.CallMeta meta) internal view {
        address gravix_acc = getGravixAccountAddress(user);
        uint16 flag = value == 0 ? MsgFlag.ALL_NOT_RESERVED : 0;
        IGravixAccount(gravix_acc).upgrade{ value: value, flag: flag }(GravixAccountCode, GravixAccountVersion, meta);
    }

    function onGravixAccountUpgrade(
        address user,
        uint32 old_version,
        uint32 new_version,
        Callback.CallMeta meta
    ) external view onlyGravixAccount(user) reserveAndSuccessCallback(meta) {
        emit GravixAccountUpgrade(meta.call_id, user, old_version, new_version);
    }

    function onGravixAccountDeploy(address user, Callback.CallMeta meta) external view override onlyGravixAccount(user) reserveAndSuccessCallback(meta) {
        emit GravixAccountDeploy(user);
    }

    function deployGravixAccount(
        address user, Callback.CallMeta meta
    ) external view responsible reserveAndSuccessCallback(meta) returns (address account) {
        require (msg.value > Gas.GRAVIX_ACCOUNT_DEPLOY_VALUE, Errors.LOW_MSG_VALUE);
        account = _deployGravixAccount(user);
    }

    function _deployGravixAccount(address user) internal view returns (address) {
        TvmBuilder constructor_params;

        constructor_params.store(GravixAccountVersion); // 32
        constructor_params.store(GravixAccountVersion); // 32

        return new Platform{
            stateInit: _buildGravixAccountInitData(_buildGravixAccountParams(user)),
            value: Gas.GRAVIX_ACCOUNT_DEPLOY_VALUE
        }(GravixAccountCode, constructor_params.toCell(), user);
    }
}
