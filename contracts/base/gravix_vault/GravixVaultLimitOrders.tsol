pragma ever-solidity ^0.62.0;


import "../../interfaces/IGravixAccount.tsol";
import "../../interfaces/IOracleProxy.tsol";
import "../../libraries/Callback.tsol";
import "./GravixVaultMarkets.tsol";
import "./GravixVaultOrdersBase.tsol";
import "@broxus/contracts/contracts/libraries/MsgFlag.tsol";

import {DateTime as DateTimeLib} from "../../libraries/DateTime.tsol";


abstract contract GravixVaultLimitOrders is GravixVaultOrdersBase {

    // region request order
    function _handleLimitOrder(
        address _user,
        uint128 collateral,
        TvmCell orderParamsPayload,
        Callback.CallMeta meta
    ) internal returns (bool) {
        (
            uint32 marketIdx,
            PositionType positionType,
            uint32 leverage,
            uint128 targetPrice,
            LimitOrderType limitOrderType,
            IPriceNode.Price price,
            address referrer
        ) = decodeLimitOrder(orderParamsPayload);

        if (!validateOrderParams(marketIdx, collateral, leverage, 0)) return false;
        // TODO check position allowed
        if (!marketOpen(marketIdx)) return false;

        _limitOrder(
            _user,
            marketIdx,
            positionType,
            collateral,
            leverage,
            targetPrice,
            limitOrderType,
            price,
            referrer,
            meta
        );
        return true;
    }

    function _limitOrder(
        address _user,
        uint32 _marketIdx,
        PositionType _positionType,
        uint128 _collateral,
        uint32 _leverage,
        uint128 _targetPrice,
        LimitOrderType _limitOrderType,
        IPriceNode.Price _price,
        address _referrer,
        Callback.CallMeta _meta
    ) internal {

        _sendOpenOrderOracleLimitRequest(
            _user,
            requestNonce,
            _marketIdx,
            _collateral,
            _leverage,
            _positionType,
            _limitOrderType,
            _referrer,
            _targetPrice,
            _price,
            _meta
        );
    }

    function _sendOpenOrderOracleLimitRequest(
        address _user,
        uint32 _positionKey,
        uint32 _marketIdx,
        uint128 _collateral,
        uint32 _leverage,
        PositionType _positionType,
        LimitOrderType _limitOrderType,
        address _referer,
        uint128 _targetPrice,
        IPriceNode.Price _userPrice,
        Callback.CallMeta _meta
    ) internal view {
        address proxy = _deployOracleProxy(_marketIdx, _meta);
        IOracleProxy(proxy).setRequestLimitCallback{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _user,
            _positionKey,
            _collateral,
            _leverage,
            _positionType,
            _limitOrderType,
            _referer,
            _targetPrice,
            _userPrice
        );
    }
    function oracle_requestLimitOrder(
        uint64 _nonce,
        address _user,
        uint32 _marketIdx,
        PositionType _positionType,
        uint128 _collateral,
        uint32 _leverage,
        uint128 _targetPrice,
        LimitOrderType _limitOrderType,
        IPriceNode.Price _price,
        address _referrer,
        Callback.CallMeta _meta,
        uint128 _assetPrice
    ) external override onlyOracleProxy(_nonce) reserve {
        Market _market = markets[_marketIdx];
        requestNonce += 1;
        uint128 positionSizeAsset = calculatePositionAssetSize(_collateral, _leverage, _assetPrice);
        PendingLimitOrder newRequest = PendingLimitOrder(
            _user,
            _marketIdx,
            _positionType,
            _collateral,
            _targetPrice,
            _limitOrderType,
            _leverage,
            _market.fees.openFeeRate,
            _market.fees.closeFeeRate,
            _market.fees.baseSpreadRate,
            liquidationParams.thresholdRate,
            _market.fees.borrowBaseRatePerHour,
            _price,
            _referrer,
            _assetPrice,
            positionSizeAsset,
            _meta
        );
        pendingLimitRequests[requestNonce] = newRequest;


        _requestLimitOrder(newRequest, requestNonce);
    }

    function _requestLimitOrder(
        IGravixVault.PendingLimitOrder _pendingLimitOrder,
        uint32 _requestNonce
    ) internal {
        // reserve should be
        address gravixAcc = getGravixAccountAddress(_pendingLimitOrder.user);

        IGravixAccount(gravixAcc).process_requestLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
            _requestNonce,
            _pendingLimitOrder,
            gravixAccountCode.version
        );
    }

    function revert_requestLimitOrder(
        uint32 _reqNonce,
        PendingLimitOrder _pendRequest
    ) external override onlyGravixAccount(_pendRequest.user) reserve {
        delete pendingLimitRequests[_reqNonce];
        emit LimitOrderRequestRevert(_pendRequest.meta.callId, _pendRequest.user);
        if (_pendRequest.collateral > 0) {
            _transfer(
                usdt.wallet,
                _pendRequest.collateral,
                _pendRequest.user,
                _makeCell(_pendRequest.meta.nonce),
                _pendRequest.meta.sendGasTo,
                MsgFlag.ALL_NOT_RESERVED
            );
        } else {
            _sendCallbackOrGas(
                _pendRequest.user,
                _pendRequest.meta.nonce,
                false, _pendRequest.meta.sendGasTo
            );
        }
    }

    function finish_requestLimitOrder(
        uint32 reqNonce,
        PendingLimitOrder request,
        uint32 positionKey
    ) external override onlyGravixAccount(request.user) reserve {
        delete pendingLimitRequests[reqNonce];
        collateralReserve += request.collateral;

        emit LimitOrder(
            request.meta.callId,
            request.user,
            request.marketIdx,
            request.positionType,
            request.orderType,
            request.collateral,
            request.targetPrice,
            request.leverage,
            positionKey
        );

    }

    //endregion

    // region limit bot
    function limitBot_executeLimitOrders(
        mapping (uint32 => ExecuteLimitOrderData) limitOrdersMap,
        Callback.CallMeta meta
    ) external override onlyLimitBot reserve {
        for ((uint32 marketIdx, ExecuteLimitOrderData limitOrders) : limitOrdersMap) {
            OracleType priceSource = markets[marketIdx].priceSource;
            OracleConfig oracleConf = oracleConfigs[marketIdx];

            // if market uses offchain oracle and we have valid price, we can liquidate positions right now
            if (priceSource == OracleType.PriceNode && checkPrice(limitOrders.price, oracleConf.priceNode)) {
                uint128 value = uint128(limitOrders.positions.length * Gas.LIQUIDATION_VALUE) + Gas.ORACLE_PROXY_DEPLOY;
                this.self_liquidatePositions{value: value}(
                    msg.sender,
                    marketIdx,
                    liqData.positions,
                    liqData.price.price,
                    meta,
                    0
                );
                continue;
            }

            _sendExecuteLimitOracleRequest(
                marketIdx,
                limitOrders.positions,
                meta
            );
        }

    }

    function self_executeLimitOrders() external reserve {
        require (msg.sender == address(this), Errors.BAD_SENDER);

    }

    function _sendExecuteLimitOracleRequest(
        uint32 _marketIdx,
        LimitPositionIdx[] _limitPositions,
        Callback.CallMeta _meta
    ) internal {
        address proxy = _deployOracleProxy(_marketIdx, _meta);
        IOracleProxy(proxy).setExecuteLimitCallback{
            value: 0,
            flag: MsgFlag.ALL_NOT_RESERVED
        }(
        //todo msg.sneder?
            msg.sender,
            _limitPositions
        );
    }
    function oracle_executeLimitOrder(
        uint64 _nonce,
        LimitPositionIdx[] limitPositions,
        uint128 _assetPrice,
        Callback.CallMeta _meta
    ) external override onlyOracleProxy(_nonce) reserve {
        for (LimitPositionIdx limitPosition : limitPositions) {
            _executeLimitOrder(
                limitPosition.user,
                limitPosition.positionKey,
                limitPosition.marketIdx,
                limitPosition.collateral,
                limitPosition.leverage,
                limitPosition.positionType,
                _assetPrice,
                _meta
            );
        }

        _meta.sendGasTo.transfer({value: 0, flag: MsgFlag.ALL_NOT_RESERVED});
    }

    function _executeLimitOrder(
        address user,
        uint32 positionKey,
        uint32 marketIdx,
        uint128 collateral,
        uint32 leverage,
        PositionType positionType,
        uint128 assetPrice,
        Callback.CallMeta meta
    ) internal {
        // reserve should be
        uint128 positionSizeAsset = calculatePositionAssetSize(collateral, leverage, assetPrice);

        Funding _funding = _updateFunding(marketIdx, assetPrice);
        uint16 _error = _addPositionToMarketOrReturnErr(marketIdx, positionSizeAsset, assetPrice, positionType);

        address gravixAcc = getGravixAccountAddress(user);
        if (_error == 0) {
            int256 funding = positionType == PositionType.Long ? _funding.accLongUSDFundingPerShare : _funding.accShortUSDFundingPerShare;
            // todo add constant value
            IGravixAccount(gravixAcc).process_executeLimitOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                positionKey,
                marketIdx,
                positionSizeAsset,
                positionType,
                assetPrice,
                funding,
                meta,
                gravixAccountCode.version
            );
        } else {
            //todo
            // order cant be executed now, some limits reached and etc.
            IGravixAccount(gravixAcc).process_cancelMarketOrder{value: 0, flag: MsgFlag.ALL_NOT_RESERVED}(
                positionKey,
                meta,
                gravixAccountCode.version
            );
        }
    }
    //endregion
//todo
    function finish_executeLimitOrder(
        address user,
        uint32 positionKey,
        IGravixAccount.Position newPos,
        address referrer,
        address grandReferrer,
        Callback.CallMeta meta
    ) external override onlyGravixAccount(user) reserveAndSuccessCallback(meta) {
        _collectOpenFeeAndReferral(newPos.openFee, referrer, grandReferrer, user, meta);
        collateralReserve -= newPos.openFee;

        uint128 positionSizeAssetRaw = calculatePositionAssetSize(newPos.initialCollateral, newPos.leverage, newPos.markPrice);
        _removePositionFromMarket(newPos.marketIdx, positionSizeAssetRaw, newPos.markPrice, newPos.positionType);

        uint128 positionSizeAsset = calculatePositionAssetSize(newPos.initialCollateral - newPos.openFee, newPos.leverage, newPos.openPrice);
        _addPositionToMarket(newPos.marketIdx, positionSizeAsset, newPos.markPrice, newPos.positionType);

        emit MarketOrderExecution(
            meta.callId,
            user,
            newPos,
            positionKey
        );
    }

}
